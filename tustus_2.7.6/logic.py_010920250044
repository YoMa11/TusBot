# logic.py
from __future__ import annotations
import re
import logging
from typing import Any, Dict, List, Optional
import requests
from bs4 import BeautifulSoup

import db  # מודול ה־DB המקומי שלך

log = logging.getLogger(__name__)

# -------- Helpers --------
_SPACE = re.compile(r"\s+")
def _clean(t: Optional[str]) -> str:
    return _SPACE.sub(" ", (t or "").strip())

def _split_city_country(destination: str) -> tuple[str, str]:
    # "אתונה - יוון" -> ("אתונה","יוון")
    if " - " in destination:
        a, b = destination.split(" - ", 1)
        return _clean(a), _clean(b)
    return _clean(destination), ""

def _parse_price_text(txt: str) -> tuple[Optional[float], str, str]:
    """
    מקבל price_text כמו '$150' או '₪ 200' ומחזיר (price, currency, price_text_norm).
    """
    t = _clean(txt)
    if not t:
        return None, "", ""
    # נסה לחלץ מטבע
    currency = ""
    if "₪" in t or "שח" in t or "ש״ח" in t or "ש\"ח" in t:
        currency = "ILS"
    elif "$" in t or "USD" in t:
        currency = "USD"
    else:
        # נסה לחלץ גם מה-data attribute (ימוקם בשלב איסוף)
        currency = ""
    # מספר
    m = re.search(r"([0-9]+(?:\.[0-9]+)?)", t.replace(",", ""))
    price = float(m.group(1)) if m else None
    return price, currency, t

def _text_or_attr(node, selector: str, attr: Optional[str] = None) -> str:
    el = node.select_one(selector)
    if not el:
        return ""
    if attr:
        return str(el.get(attr) or "")
    return el.get_text(strip=True)

# -------- Scraper according to HTML Contract --------
# ראה הטבלה ב־html_contract.html שהעלית: אנחנו נאסוף את כל השדות שם.  [oai_citation:2‡html_contract.html](file-service://file-U7m7P3QbTj2VAZpW2YKf6t)
def scrape_items(html: str) -> List[Dict[str, Any]]:
    soup = BeautifulSoup(html, "lxml")
    items: List[Dict[str, Any]] = []
    for card in soup.select(".show_item"):
        # מזהים
        item_id = card.get("data_ga_item_id") or card.get("ite_item") or ""
        selapp_item = card.get("ite_selappitem") or ""
        category = card.get("category") or ""
        provider = card.get("data_ga_item_category4") or ""
        affiliation = card.get("data_ga_affiliation") or ""
        promo_category = card.get("data_ga_item_category") or ""

        destination = card.get("data_ga_item_name") or card.get("con_desc") or ""
        destination = _clean(destination)
        dest_city, dest_country = _split_city_country(destination)

        trip_title = _text_or_attr(card, ".show_item_name")
        img_url = _text_or_attr(card, ".show_item_img img", "src")
        badge_text = _text_or_attr(card, ".spcial_message_bottom")

        price_text_raw = _text_or_attr(card, ".show_item_total_price")
        # ננסה קודם data attr
        num_price_attr = card.get("data_number_ga_price") or ""
        currency_attr = card.get("data_ga_currency") or ""
        price_val, currency, price_text_norm = _parse_price_text(price_text_raw)
        if not price_val:
            try:
                price_val = float(num_price_attr) if num_price_attr else None
            except Exception:
                price_val = None
        if not currency and currency_attr:
            currency = currency_attr

        note = _text_or_attr(card, ".flight_note")
        more_like = _text_or_attr(card, ".more_like_this")

        # הלוך
        out_from_city  = _text_or_attr(card, ".flight_go .from .text-gray")
        out_from_time  = _text_or_attr(card, ".flight_go .from .flight_hourTime")
        out_from_date  = _text_or_attr(card, ".flight_go .from .text-gray + .flight_hourTime")  # fallback
        # בדף אצלך, התאריך יושב באותה .from מתחת לשעה; ננסה לאלטרנטיבה:
        if not out_from_date:
            out_from_date = _text_or_attr(card, ".flight_go .from .text-gray:nth-of-type(2)")

        out_to_city    = _text_or_attr(card, ".flight_go .to .text-gray")
        out_to_time    = _text_or_attr(card, ".flight_go .to .flight_hourTime")
        out_to_date    = _text_or_attr(card, ".flight_go .to .text-gray:nth-of-type(2)")

        # חזור
        back_from_city = _text_or_attr(card, ".flight_back .from .text-gray")
        back_from_time = _text_or_attr(card, ".flight_back .from .flight_hourTime")
        back_from_date = _text_or_attr(card, ".flight_back .from .text-gray:nth-of-type(2)")

        back_to_city   = _text_or_attr(card, ".flight_back .to .text-gray")
        back_to_time   = _text_or_attr(card, ".flight_back .to .flight_hourTime")
        back_to_date   = _text_or_attr(card, ".flight_back .to .text-gray:nth-of-type(2)")

        items.append({
            "item_id": item_id, "selapp_item": selapp_item, "category": category,
            "provider": provider, "affiliation": affiliation, "promo_category": promo_category,
            "destination": destination, "dest_city": dest_city, "dest_country": dest_country,
            "trip_title": trip_title, "img_url": img_url, "badge_text": badge_text,
            "note": note, "more_like": more_like,
            "price": price_val, "currency": currency, "price_text": price_text_norm or price_text_raw,
            "out_from_city": out_from_city, "out_from_date": out_from_date, "out_from_time": out_from_time,
            "out_to_city": out_to_city, "out_to_date": out_to_date, "out_to_time": out_to_time,
            "back_from_city": back_from_city, "back_from_date": back_from_date, "back_from_time": back_from_time,
            "back_to_city": back_to_city, "back_to_date": back_to_date, "back_to_time": back_to_time,
        })
    return items

# -------- Monitor Job --------
def monitor_job(conn, app) -> dict:
    """
    רץ ע"י ה־JobQueue. מושך HTML, גורד, עושה UPSERT, ומחזיר סטטוס.
    אין Threading – כדי לא להיתקע על 'SQLite objects created in a thread…'
    """
    # URL מגיע מה־config דרך ה־app (handlers/app שלך שומרים context? לא נוגעים בזה כאן)
    # כדי לא לגעת בקונפיג, ננסה להביא מה-application.bot_data אם שמתם שם.
    url = None
    try:
        url = getattr(app, "bot_data", {}).get("URL")  # אופציונלי
    except Exception:
        url = None
    if not url:
        # fallback בטוח שלא משנה config.py שלך
        url = "https://www.tustus.co.il/Arkia/Home"

    log.info("Scraping: %s", url)
    r = requests.get(url, timeout=15, headers={
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                      "(KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
    })
    r.raise_for_status()
    items = scrape_items(r.text)
    if not items:
        log.warning("Scraper found 0 items")

    ins, upd = db.upsert_flights(conn, items)
    return {"inserted": ins, "updated": upd, "total": len(items)}

# async API ש־app.py שלך קורא ממנו
async def run_monitor(conn, app) -> None:
    try:
        res = monitor_job(conn, app)
        log.info("monitor_job: upserted %s", res)
    except Exception as e:
        log.exception("monitor_job raised: %s", e)

# ===== UI helpers expected by handlers.py =====

def count_totals(conn):
    """
    מחזיר (total_active, total_all)
    total_active = רשומות פעילות כרגע (is_active=1)
    total_all    = כל הרשומות בטבלה
    """
    cur = conn.cursor()
    total_all = cur.execute("SELECT COUNT(*) FROM flights").fetchone()[0]
    # אם השדה is_active לא קיים אצלך – שנה ל- last_seen בתוך חלון זמן, למשל שעה אחרונה:
    # total_active = cur.execute("SELECT COUNT(*) FROM flights WHERE last_seen >= datetime('now','-1 hour')").fetchone()[0]
    try:
        total_active = cur.execute(
            "SELECT COUNT(*) FROM flights WHERE is_active = 1"
        ).fetchone()[0]
    except Exception:
        # פולבק אם is_active לא קיים בסכמה
        total_active = cur.execute(
            "SELECT COUNT(*) FROM flights WHERE last_seen >= datetime('now','-1 hour')"
        ).fetchone()[0]
    return int(total_active), int(total_all)


def list_destinations(conn, include_all=True):
    """
    מחזיר רשימת יעדים לתצוגה: [(country, city, display_name), ...]
    מסודר: מדינה -> עיר. כולל 'כל היעדים' אם include_all=True.
    """
    rows = conn.execute(
        """
        SELECT
            COALESCE(dest_country, '') AS country,
            COALESCE(dest_city, '')    AS city
        FROM flights
        GROUP BY country, city
        ORDER BY country COLLATE NOCASE, city COLLATE NOCASE
        """
    ).fetchall()

    items = []
    if include_all:
        items.append(('', '', '🌍 כל היעדים'))

    for r in rows:
        country = r["country"] or ""
        city = r["city"] or ""
        if country and city:
            disp = f"{country} · {city}"
        elif country:
            disp = country
        elif city:
            disp = city
        else:
            disp = "לא ידוע"
        items.append((country, city, disp))

    return items


# שמירה על חתימה שמצופה מ-app.py (אם חסר/השתנתה בעבר)
import asyncio as _asyncio

async def run_monitor(conn, app=None):
    """
    מריץ את monitor_job באותו Thread (או to_thread אם כבד).
    שומר על חתימה: (conn, app) כדי ש-app.py יוכל לקרוא תמיד.
    """
    # אם monitor_job היא סינכרונית:
    return await _asyncio.to_thread(monitor_job, conn, app)
    # אם אצלך monitor_job כבר async, אפשר פשוט:
    # return await monitor_job(conn, app)
