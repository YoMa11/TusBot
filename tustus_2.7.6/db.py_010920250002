from __future__ import annotations
import sqlite3
from typing import Optional, Iterable, Dict, Any

def get_conn(path: Optional[str] = None) -> sqlite3.Connection:
    """Open a SQLite connection with row access by column name."""
    db_path = path or "./flights.db"
    conn = sqlite3.connect(db_path, isolation_level=None, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    ensure_schema(conn)
    return conn

def ensure_schema(conn: sqlite3.Connection) -> None:
    """Create/upgrade schema to the rich flights table."""
    conn.execute("PRAGMA journal_mode=WAL;")
    conn.execute("PRAGMA foreign_keys=ON;")

    # אם כבר קיימת טבלה ישנה (columns: destination, price, currency...), נמיר אותה בזהירות
    cols = [r["name"] for r in conn.execute("PRAGMA table_info(flights);").fetchall()] if \
        conn.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='flights';").fetchone() else []

    if cols and {"destination","price","currency","url","last_seen"}.issubset(set(cols)) and "dest_city" not in cols:
        _migrate_old_to_rich(conn)

    # צור טבלה עשירה אם לא קיימת
    conn.execute("""
    CREATE TABLE IF NOT EXISTS flights (
        id INTEGER PRIMARY KEY,
        item_id TEXT,
        selapp_item TEXT,
        category TEXT,
        provider TEXT,
        affiliation TEXT,
        promo_category TEXT,
        destination TEXT,
        dest_city TEXT,
        dest_country TEXT,
        trip_title TEXT,
        price REAL,
        currency TEXT,
        price_text TEXT,
        img_url TEXT,
        badge_text TEXT,

        out_from_city TEXT,
        out_from_date TEXT,
        out_from_time TEXT,
        out_to_city   TEXT,
        out_to_date   TEXT,
        out_to_time   TEXT,

        back_from_city TEXT,
        back_from_date TEXT,
        back_from_time TEXT,
        back_to_city   TEXT,
        back_to_date   TEXT,
        back_to_time   TEXT,

        note TEXT,
        more_like TEXT,
        url TEXT,

        is_active INTEGER DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_seen  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

        UNIQUE(item_id, selapp_item)
    );
    """)

    # אינדקסים שימושיים
    conn.execute("CREATE INDEX IF NOT EXISTS idx_flights_dest ON flights(dest_city, dest_country);")
    conn.execute("CREATE INDEX IF NOT EXISTS idx_flights_last_seen ON flights(last_seen);")
    conn.execute("CREATE INDEX IF NOT EXISTS idx_flights_active ON flights(is_active);")

def _migrate_old_to_rich(conn: sqlite3.Connection) -> None:
    """Upgrade legacy flights schema -> rich schema, משמר נתונים קיימים."""
    conn.executescript("""
    PRAGMA legacy_alter_table=ON;

    CREATE TABLE IF NOT EXISTS flights_new (
        id INTEGER PRIMARY KEY,
        item_id TEXT,
        selapp_item TEXT,
        category TEXT,
        provider TEXT,
        affiliation TEXT,
        promo_category TEXT,
        destination TEXT,
        dest_city TEXT,
        dest_country TEXT,
        trip_title TEXT,
        price REAL,
        currency TEXT,
        price_text TEXT,
        img_url TEXT,
        badge_text TEXT,

        out_from_city TEXT,
        out_from_date TEXT,
        out_from_time TEXT,
        out_to_city   TEXT,
        out_to_date   TEXT,
        out_to_time   TEXT,

        back_from_city TEXT,
        back_from_date TEXT,
        back_from_time TEXT,
        back_to_city   TEXT,
        back_to_date   TEXT,
        back_to_time   TEXT,

        note TEXT,
        more_like TEXT,
        url TEXT,

        is_active INTEGER DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_seen  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

        UNIQUE(item_id, selapp_item)
    );

    INSERT INTO flights_new(destination, price, currency, url, last_seen, created_at, updated_at, is_active)
    SELECT destination, price, currency, url, last_seen, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 1
    FROM flights;

    DROP TABLE flights;
    ALTER TABLE flights_new RENAME TO flights;
    """)

def mark_all_inactive(conn: sqlite3.Connection) -> None:
    conn.execute("UPDATE flights SET is_active = 0;")

def upsert_batch(conn: sqlite3.Connection, items: Iterable[Dict[str, Any]]) -> tuple[int,int]:
    """UPSERT by (item_id, selapp_item). Returns (inserted, updated)."""
    ins = upd = 0
    sql = """
    INSERT INTO flights(
        item_id, selapp_item, category, provider, affiliation, promo_category,
        destination, dest_city, dest_country, trip_title,
        price, currency, price_text, img_url, badge_text,
        out_from_city, out_from_date, out_from_time, out_to_city, out_to_date, out_to_time,
        back_from_city, back_from_date, back_from_time, back_to_city, back_to_date, back_to_time,
        note, more_like, url, is_active, created_at, updated_at, last_seen
    )
    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,1,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP)
    ON CONFLICT(item_id, selapp_item) DO UPDATE SET
        category=excluded.category,
        provider=excluded.provider,
        affiliation=excluded.affiliation,
        promo_category=excluded.promo_category,
        destination=excluded.destination,
        dest_city=excluded.dest_city,
        dest_country=excluded.dest_country,
        trip_title=excluded.trip_title,
        price=excluded.price,
        currency=excluded.currency,
        price_text=excluded.price_text,
        img_url=excluded.img_url,
        badge_text=excluded.badge_text,
        out_from_city=excluded.out_from_city,
        out_from_date=excluded.out_from_date,
        out_from_time=excluded.out_from_time,
        out_to_city=excluded.out_to_city,
        out_to_date=excluded.out_to_date,
        out_to_time=excluded.out_to_time,
        back_from_city=excluded.back_from_city,
        back_from_date=excluded.back_from_date,
        back_from_time=excluded.back_from_time,
        back_to_city=excluded.back_to_city,
        back_to_date=excluded.back_to_date,
        back_to_time=excluded.back_to_time,
        note=excluded.note,
        more_like=excluded.more_like,
        url=excluded.url,
        is_active=1,
        updated_at=CURRENT_TIMESTAMP,
        last_seen=CURRENT_TIMESTAMP
    ;
    """
    cur = conn.cursor()
    for it in items:
        args = (
            it.get("item_id"), it.get("selapp_item"), it.get("category"), it.get("provider"),
            it.get("affiliation"), it.get("promo_category"), it.get("destination"),
            it.get("dest_city"), it.get("dest_country"), it.get("trip_title"),
            it.get("price"), it.get("currency"), it.get("price_text"), it.get("img_url"),
            it.get("badge_text"),
            it.get("out_from_city"), it.get("out_from_date"), it.get("out_from_time"),
            it.get("out_to_city"), it.get("out_to_date"), it.get("out_to_time"),
            it.get("back_from_city"), it.get("back_from_date"), it.get("back_from_time"),
            it.get("back_to_city"), it.get("back_to_date"), it.get("back_to_time"),
            it.get("note"), it.get("more_like"), it.get("url"),
        )
        try:
            cur.execute(sql, args)
            if cur.rowcount == 1 and cur.lastrowid:  # heuristic insert
                ins += 1
            else:
                upd += 1
        except sqlite3.IntegrityError:
            upd += 1
    return ins, upd
