# telegram_view.py
from __future__ import annotations
from typing import Iterable, List, Sequence, Tuple, Dict, Any, Optional
from datetime import datetime, timezone
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

# Small helpers to keep labels consistent

def _ok(active: bool) -> str:
    return "âœ… " if active else ""

def _fmt_price(cur: str, price: Optional[float]) -> str:
    if not price:
        return ""
    try:
        iv = int(price)
    except Exception:
        return f"{cur}{price}"
    return f"{cur}{iv}"

def _chunk(seq: Sequence, n: int) -> List[List]:
    return [list(seq[i:i+n]) for i in range(0, len(seq), n)]

# Greeting text that rotates every ~2 hours deterministically so all users see same text
_GREETINGS = [
    "×”×™×™, ×–×” ×˜×•×¡×˜×•×¡. ×§×¤×” ×œ××•×¨×š ×”×ž×¡×œ×•×œ ×¢×œ×™×™. â˜•ï¸",
    "×”×™×™, ×–×” ×˜×•×¡×˜×•×¡. ×ž×¦××ª×™ ×›×¨×˜×™×¡×™× â€“ ××ª×” ×ž×‘×™× ××ª ×”×‘×ž×‘×”. ðŸ¥³",
    "×”×™×™, ×–×” ×˜×•×¡×˜×•×¡. ×œ××Ÿ ×˜×¡×™× ×”×™×•×? ×× ×™ ×¨×§ ×©×•××œ ×‘×©×‘×™×œ ×—×‘×¨. ðŸ˜",
    "×”×™×™, ×–×” ×˜×•×¡×˜×•×¡. ×ž×‘×¦×¢ ×˜×•×‘ ×™×•×ª×¨ ×ž×ž×—×™×¨×™ duty free. ××•×œ×™. ðŸ›ï¸",
]

def build_header_text(total_active: int, total_all: int, state_line: str | None = None) -> str:
    idx = (int(datetime.now(timezone.utc).timestamp()) // (60 * 60 * 2)) % len(_GREETINGS)
    greeting = _GREETINGS[idx]
    base = f"{greeting}\n×™×© ×›×¨×’×¢ {total_active} ×ž×‘×¦×¢×™× ×¤×¢×™×œ×™× (×¡×”\"×› {total_all})."
    if state_line:
        base += f"\n×‘×—×™×¨×•×ª: {state_line}"
    return base

def build_destinations_row(options: Sequence[Tuple[str, str, bool]]) -> List[List[InlineKeyboardButton]]:
    """options: list of (label, callback_data, selected?)"""
    buttons = [
        InlineKeyboardButton(_ok(sel) + label, callback_data=data)
        for (label, data, sel) in options
    ]
    return _chunk(buttons, 2)

def build_dates_block(date_labels: Sequence[Tuple[str, str, bool]], mode_labels: Sequence[Tuple[str, str, bool]]) -> List[List[InlineKeyboardButton]]:
    # first row: "×‘×œ×™ ×ª××¨×™×š" centered between two fillers if needed
    date_buttons = [InlineKeyboardButton(_ok(sel)+label, callback_data=data) for (label, data, sel) in date_labels]
    rows: List[List[InlineKeyboardButton]] = []
    rows.append(_chunk(date_buttons[:8], 4)[0] if len(date_buttons) >= 4 else [*date_buttons])
    # modes row
    mode_buttons = [InlineKeyboardButton(_ok(sel)+label, callback_data=data) for (label, data, sel) in mode_labels]
    rows.append(mode_buttons)
    return rows

def build_seats_row(values: Sequence[Tuple[str, str, bool]]) -> List[List[InlineKeyboardButton]]:
    btns = [InlineKeyboardButton(_ok(sel)+label, callback_data=data) for (label, data, sel) in values]
    return [_chunk(btns, 5)[0] if len(btns) >= 5 else btns]

def build_visibility_row(values: Sequence[Tuple[str, str, bool]]) -> List[List[InlineKeyboardButton]]:
    btns = [InlineKeyboardButton(_ok(sel)+label, callback_data=data) for (label, data, sel) in values]
    return [_chunk(btns, 3)[0] if len(btns) >= 3 else btns]

def build_footer_row() -> List[List[InlineKeyboardButton]]:
    return [
        [
            InlineKeyboardButton("ðŸ”„ ×¨×¢× ×•×Ÿ", callback_data="act:refresh"),
            InlineKeyboardButton("ðŸ“Š ×¡×™×›×•× ×™×¢×“×™×", callback_data="act:summary"),
        ]
    ]

def build_keyboard(blocks: List[List[List[InlineKeyboardButton]]]) -> InlineKeyboardMarkup:
    # flatten list of blocks (each block is list of rows)
    rows: List[List[InlineKeyboardButton]] = []
    for block in blocks:
        rows.extend(block)
    return InlineKeyboardMarkup(rows)
