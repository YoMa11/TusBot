# logic.py
from __future__ import annotations
import asyncio
import logging
import re
import sqlite3
import time
from datetime import datetime, timedelta, timezone
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

import requests
from bs4 import BeautifulSoup

import config

log = logging.getLogger(__name__)

# ———————————————————————————————————————————————————
# Utilities
# ———————————————————————————————————————————————————

def _utcnow() -> datetime:
    return datetime.now(timezone.utc)

def _table_columns(conn: sqlite3.Connection, table: str) -> List[str]:
    cur = conn.execute(f"PRAGMA table_info({table})")
    return [r[1] for r in cur.fetchall()]

def _has_cols(conn: sqlite3.Connection, table: str, cols: Sequence[str]) -> bool:
    existing = set(_table_columns(conn, table))
    return all(c in existing for c in cols)

def _choose_first_present(conn: sqlite3.Connection, table: str, candidates: Sequence[str]) -> Optional[str]:
    existing = set(_table_columns(conn, table))
    for c in candidates:
        if c in existing:
            return c
    return None

def _coerce_float(s: str) -> Optional[float]:
    if s is None:
        return None
    m = re.findall(r"[0-9]+(?:[.,][0-9]+)?", s.replace(",", ""))
    if not m:
        return None
    try:
        return float(m[0])
    except Exception:
        return None

# ———————————————————————————————————————————————————
# Scrape according to HTML contract (html_contract.html)
# ———————————————————————————————————————————————————

def _fetch_html(url: str, timeout: int = 15) -> str:
    headers = {
        "User-Agent": config.USER_AGENT,
    }
    r = requests.get(url, headers=headers, timeout=timeout)
    r.raise_for_status()
    return r.text

def _parse_items(html: str) -> List[Dict]:
    """
    Extract items per html contract: one result per .show_item
    """
    soup = BeautifulSoup(html, "lxml")
    out: List[Dict] = []
    for div in soup.select(".show_item"):
        get = div.get

        destination = get("data_ga_item_name") or get("con_desc") or ""
        # split to city / country if possible
        city, country = "", ""
        if destination:
            parts = [p.strip() for p in destination.split("-", 1)]
            if len(parts) == 2:
                city, country = parts[0], parts[1]
            else:
                city = destination

        # price + currency
        price_attr = get("data_number_ga_price")
        price_text = (div.select_one(".show_item_total_price") or {}).get_text(strip=True) if div.select_one(".show_item_total_price") else ""
        price = _coerce_float(price_attr or price_text) or 0.0
        currency = get("data_ga_currency") or (("$" if "$" in price_text or "USD" in price_text else "₪" if any(sym in price_text for sym in ("₪","שח","ש\"ח","ש״ח")) else ""))

        # images / labels
        img_url = (div.select_one(".show_item_img img") or {}).get("src", "") if div.select_one(".show_item_img img") else ""
        badge_el = div.select_one(".spcial_message_bottom")
        badge_text = badge_el.get_text(" ", strip=True) if badge_el else ""

        # details blocks (flight go/back)
        def _tx(node, sel):
            el = node.select_one(sel)
            return el.get_text(" ", strip=True) if el else ""

        go = div.select_one(".flight_go") or soup.new_tag("div")
        back = div.select_one(".flight_back") or soup.new_tag("div")

        out_from_city = _tx(go, ".from .text-gray")
        out_from_time = _tx(go, ".from .flight_hourTime")
        out_from_date = _tx(go, ".from .text-gray:nth-of-type(2)")
        out_to_city   = _tx(go, ".to .text-gray")
        out_to_time   = _tx(go, ".to .flight_hourTime")
        out_to_date   = _tx(go, ".to .text-gray:nth-of-type(2)")

        back_from_city = _tx(back, ".from .text-gray")
        back_from_time = _tx(back, ".from .flight_hourTime")
        back_from_date = _tx(back, ".from .text-gray:nth-of-type(2)")
        back_to_city   = _tx(back, ".to .text-gray")
        back_to_time   = _tx(back, ".to .flight_hourTime")
        back_to_date   = _tx(back, ".to .text-gray:nth-of-type(2)")

        note = (div.select_one(".flight_note") or soup.new_tag("div")).get_text(" ", strip=True)
        more_like = (div.select_one(".more_like_this") or soup.new_tag("div")).get_text(" ", strip=True)

        # ids
        item_id = get("data_ga_item_id") or get("ite_item") or ""
        selapp_item = get("ite_selappitem") or ""
        provider = get("data_ga_item_category4") or ""
        affiliation = get("data_ga_affiliation") or ""
        category = get("category") or ""
        promo_category = get("data_ga_item_category") or ""
        trip_title = (div.select_one(".show_item_name") or soup.new_tag("div")).get_text(" ", strip=True)

        out.append({
            "item_id": item_id,
            "selapp_item": selapp_item,
            "category": category,
            "provider": provider,
            "affiliation": affiliation,
            "promo_category": promo_category,
            "destination": destination,
            "dest_city": city,
            "dest_country": country,
            "trip_title": trip_title,
            "price": price,
            "currency": currency,
            "price_text": price_text,
            "img_url": img_url,
            "badge_text": badge_text,
            "out_from_city": out_from_city,
            "out_from_time": out_from_time,
            "out_from_date": out_from_date,
            "out_to_city": out_to_city,
            "out_to_time": out_to_time,
            "out_to_date": out_to_date,
            "back_from_city": back_from_city,
            "back_from_time": back_from_time,
            "back_from_date": back_from_date,
            "back_to_city": back_to_city,
            "back_to_time": back_to_time,
            "back_to_date": back_to_date,
            "note": note,
            "more_like": more_like,
        })
    return out

# ———————————————————————————————————————————————————
# DB upsert (non-destructive: only uses existing columns)
# ———————————————————————————————————————————————————

def _db_upsert(conn: sqlite3.Connection, items: List[Dict]) -> Tuple[int, int]:
    """
    Upsert by (item_id, selapp_item) if שתי העמודות קיימות; אחרת ע"י (destination, price_text) כ־fallback.
    לא יוצר/משנה סכימה – רק משתמש בעמודות הקיימות בטבלה (flights או show_item).
    """
    # pick table name (prefer new 'flights', fallback to legacy 'show_item')
    table = "flights" if "flights" in {r[0] for r in conn.execute("SELECT name FROM sqlite_master WHERE type='table'")} else "show_item"

    cols = _table_columns(conn, table)
    now = _utcnow().isoformat()

    # Detect keys:
    has_item_id = "item_id" in cols
    has_selapp  = "selapp_item" in cols
    has_last_seen = "last_seen" in cols
    has_updated_at = "updated_at" in cols

    inserted = 0
    updated = 0

    for it in items:
        # Reduce dict to existing columns only
        payload = {k: v for k, v in it.items() if k in cols}

        # Touch timestamps if present
        if has_last_seen:
            payload["last_seen"] = now
        if has_updated_at and "updated_at" not in payload:
            payload["updated_at"] = now

        # Key where-clause
        where_args = []
        if has_item_id and has_selapp and it.get("item_id") and it.get("selapp_item"):
            where = "item_id=? AND selapp_item=?"
            where_args = [it.get("item_id"), it.get("selapp_item")]
        else:
            # fallback (weak, but non-breaking for old schema)
            key_a = "destination" if "destination" in cols else _choose_first_present(conn, table, ["dest_city", "city"])
            key_b = "price_text" if "price_text" in cols else ("price" if "price" in cols else None)
            if not key_a or not key_b:
                # No usable key; skip
                continue
            where = f"{key_a}=? AND {key_b}=?"
            where_args = [payload.get(key_a, ""), payload.get(key_b, "")]

        cur = conn.execute(f"SELECT rowid FROM {table} WHERE {where} LIMIT 1", where_args)
        row = cur.fetchone()
        if row:
            # UPDATE
            set_cols = [f"{k}=?" for k in payload.keys()]
            args = list(payload.values()) + where_args
            conn.execute(f"UPDATE {table} SET {', '.join(set_cols)} WHERE {where}", args)
            updated += 1
        else:
            # INSERT
            payload.setdefault("created_at", now) if "created_at" in cols else None
            columns = ", ".join(payload.keys())
            placeholders = ", ".join(["?"] * len(payload))
            conn.execute(f"INSERT INTO {table}({columns}) VALUES({placeholders})", list(payload.values()))
            inserted += 1

    conn.commit()
    return inserted, updated

# ———————————————————————————————————————————————————
# Public API used by app/handlers
# ———————————————————————————————————————————————————

def monitor_job(conn: sqlite3.Connection, app) -> Tuple[int, int]:
    """
    Synchronous monitor: fetch → parse → upsert. Returns (inserted, updated).
    """
    url = getattr(config, "URL", "").strip()
    if not url:
        raise RuntimeError("Missing config.URL")

    html = _fetch_html(url, timeout=getattr(config, "REQUEST_TIMEOUT", 15))
    items = _parse_items(html)
    ins, upd = _db_upsert(conn, items)
    log.info("monitor_job: parsed=%d, inserted=%d, updated=%d", len(items), ins, upd)
    return ins, upd

async def run_monitor(conn: sqlite3.Connection, app) -> None:
    """
    Async wrapper that the Application JobQueue calls.
    """
    try:
        await asyncio.to_thread(monitor_job, conn, app)
    except Exception:
        log.exception("run_monitor: monitor_job raised")

def count_totals(conn: sqlite3.Connection) -> Tuple[int, int]:
    """
    Returns (total_active, total_all).
    active := rows seen in the last 6 hours if 'last_seen' exists; otherwise all rows.
    """
    # pick table
    table = "flights" if "flights" in {r[0] for r in conn.execute("SELECT name FROM sqlite_master WHERE type='table'")} else "show_item"
    cols = set(_table_columns(conn, table))

    # total_all
    total_all = conn.execute(f"SELECT COUNT(*) FROM {table}").fetchone()[0]

    # total_active
    if "last_seen" in cols:
        since = (_utcnow() - timedelta(hours=6)).isoformat()
        total_active = conn.execute(f"SELECT COUNT(*) FROM {table} WHERE last_seen >= ?", (since,)).fetchone()[0]
    else:
        total_active = total_all

    return int(total_active), int(total_all)

def list_destinations(conn: sqlite3.Connection, limit: Optional[int] = None) -> Iterable[Tuple[str, str, Optional[float]]]:
    """
    Returns an iterable of (city, currency, min_price) for destinations,
    using best-available columns: dest_city/destination/city and currency/price.
    Only rows considered 'active' (if last_seen exists) are used for the min price.
    """
    # choose table
    table = "flights" if "flights" in {r[0] for r in conn.execute("SELECT name FROM sqlite_master WHERE type='table'")} else "show_item"
    cols = set(_table_columns(conn, table))

    # resolve city column
    city_col = "dest_city" if "dest_city" in cols else ("destination" if "destination" in cols else ("city" if "city" in cols else None))
    if city_col is None:
        return []

    # resolve currency & price
    currency_col = "currency" if "currency" in cols else None
    price_col = "price" if "price" in cols else None

    # active filter
    where = ""
    args: List[str] = []
    if "last_seen" in cols:
        since = (_utcnow() - timedelta(hours=6)).isoformat()
        where = "WHERE last_seen >= ?"
        args.append(since)

    # Build SQL to aggregate by destination
    select_min_price = f"MIN({price_col})" if price_col else "NULL"
    select_currency = currency_col or "''"

    sql = (
        f"SELECT {city_col} AS city, {select_currency} AS cur, {select_min_price} AS minp "
        f"FROM {table} "
        f"{where} "
        f"GROUP BY {city_col} "
        f"ORDER BY city COLLATE NOCASE ASC"
    )
    if limit and limit > 0:
        sql += f" LIMIT {int(limit)}"

    rows = conn.execute(sql, args).fetchall()
    result: List[Tuple[str, str, Optional[float]]] = []
    for r in rows:
        city = r[0] or ""
        cur = r[1] or ""
        minp = r[2]
        result.append((city, cur, (float(minp) if minp is not None else None)))
    return result
