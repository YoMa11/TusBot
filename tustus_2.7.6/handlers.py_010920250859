from __future__ import annotations
from typing import List, Tuple, Optional, Set
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
import time

import db
import logic

# =========================
# מצבי משתמש (user_data)
# =========================
# נשמור סט של יעדים שנבחרו בפורמט "City|Country"
UKEY_SELECTED_DESTS = "selected_dests"

# =========================
# ברכה הומוריסטית מתחלפת
# =========================
def _greeting_line(version: str = "") -> str:
    jokes = [
        "היי, זה טו־סטוס. קפה לארוך המסלול עליך ☕️",
        "אהלן! אם המחיר נמוך מדי—זה לא באג, זה אופי 😎",
        "ברוך הבא! אנחנו עוקבים אחרי מבצעים יותר מהר משהחופשה נגמרת 🏃‍♂️💨",
        "שלום! מבצע טוב יותר ממחירי duty free? לפעמים אפילו כן 🎁",
    ]
    # מתחלף כל שעתיים
    idx = (int(time.time()) // (60 * 60 * 2)) % len(jokes)
    base = jokes[idx]
    if version:
        base += f" · v{version}"
    return base

# =========================
# בניית בלוק היעדים
# =========================
def _fetch_dest_rows(conn) -> List[Tuple[str, str, str, Optional[float]]]:
    """
    מחזיר רשימת יעדים (עיר, מדינה, מטבע, מחיר מינימום) לכל היעדים ב-DB,
    כולל יעדים ישנים, לפי הסכימה העשירה של flights (dest_city, dest_country, price, currency).
    """
    return logic.list_destinations(conn)

def _format_dest_label(city: str, country: str, cur: str, min_price: Optional[float], picked: bool) -> str:
    # שם קצר וקריא
    name = f"{city} · {country}".strip(" ·")
    if len(name) > 18:
        name = name[:17] + "…"
    price = f"{cur}{int(min_price)}" if (min_price and cur) else (cur or "")
    label = name if not price else f"{price}  ·  {name}"
    if picked:
        label += " ✅"
    return label

def _build_dest_block(conn, selected: Set[str]) -> InlineKeyboardMarkup:
    rows = _fetch_dest_rows(conn)
    buttons: List[InlineKeyboardButton] = []

    # כפתור “כל היעדים”
    all_picked = "__ALL__" in selected
    all_label = "כל היעדים 🌍" + (" ✅" if all_picked else "")
    buttons.append(InlineKeyboardButton(all_label, callback_data="dst:ALL"))

    # שאר היעדים
    for city, country, cur, min_price in rows:
        key = f"{city}|{country}"
        picked = all_picked or (key in selected)
        label = _format_dest_label(city or "", country or "", cur or "", min_price, picked)
        buttons.append(InlineKeyboardButton(label, callback_data=f"dst:{key}"))

    # 2 עמודות
    keyboard: List[List[InlineKeyboardButton]] = []
    # ראשית שורה עבור "כל היעדים" בלבד
    keyboard.append([buttons[0]])
    # לאחר מכן שאר היעדים בשתי עמודות
    col = []
    for b in buttons[1:]:
        col.append(b)
        if len(col) == 2:
            keyboard.append(col)
            col = []
    if col:
        keyboard.append(col)

    # שורת בקרה תחתונה (נשאיר רק רענון כרגע)
    keyboard.append([
        InlineKeyboardButton("🔄 רענון", callback_data="refresh"),
        InlineKeyboardButton("📊 סיכום יעדים", callback_data="summary"),
    ])

    return InlineKeyboardMarkup(keyboard)

# =========================
# מסך ראשי
# =========================
def _build_main_screen(conn, selected: Set[str]) -> tuple[str, InlineKeyboardMarkup]:
    # רק ברכה בשורה העליונה (לפי דרישתך)
    # הגרסה נלקחת מ-logic.get_version() כדי לא לגעת בקבצים אחרים
    greet = _greeting_line(version=logic.get_version())
    text = greet
    km = _build_dest_block(conn, selected)
    return text, km

# =========================
# Handlers
# =========================
async def handle_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # השג/אתחל מצב בחירה למשתמש
    selected: Set[str] = set(context.user_data.get(UKEY_SELECTED_DESTS, set()))
    conn = db.get_conn()
    text, km = _build_main_screen(conn, selected)
    await update.effective_message.reply_text(text, reply_markup=km)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query
    await q.answer()
    data = (q.data or "").strip()
    conn = db.get_conn()

    selected: Set[str] = set(context.user_data.get(UKEY_SELECTED_DESTS, set()))

    if data == "refresh" or data == "home":
        text, km = _build_main_screen(conn, selected)
        old_text = q.message.text or ""
        old_km = q.message.reply_markup
        if old_text == text and str(old_km) == str(km):
            text += "\u2063"
        await q.edit_message_text(text, reply_markup=km)
        return

    if data == "summary":
        # סיכום יעדים לפי דרישה עתידית – כרגע רק מציין כמה נבחרו
        count = len(selected) if "__ALL__" not in selected else "הכול"
        text = f"📊 סיכום זמני: בחירת יעדים = {count}."
        km = _build_dest_block(conn, selected)
        old_text = q.message.text or ""
        old_km = q.message.reply_markup
        if old_text == text and str(old_km) == str(km):
            text += "\u2063"
        await q.edit_message_text(text, reply_markup=km)
        return

    if data.startswith("dst:"):
        target = data[4:]
        if target == "ALL":
            # Toggle אל/"מכל"
            if "__ALL__" in selected:
                selected.discard("__ALL__")
            else:
                selected.clear()
                selected.add("__ALL__")
        else:
            if "__ALL__" in selected:
                # אם נבחר "כל היעדים" והמשתמש בחר יעד ידני – נבטל "ALL" ונעבור לסימון פרטני
                selected.discard("__ALL__")
            if target in selected:
                selected.discard(target)
            else:
                selected.add(target)

        # שמירת המצב למשתמש
        context.user_data[UKEY_SELECTED_DESTS] = selected

        # רענון מסך
        text, km = _build_main_screen(conn, selected)
        old_text = q.message.text or ""
        old_km = q.message.reply_markup
        if old_text == text and str(old_km) == str(km):
            text += "\u2063"
        await q.edit_message_text(text, reply_markup=km)
        return

    # ברירת מחדל – חזרה למסך
    text, km = _build_main_screen(conn, selected)
    old_text = q.message.text or ""
    old_km = q.message.reply_markup
    if old_text == text and str(old_km) == str(km):
        text += "\u2063"
    await q.edit_message_text(text, reply_markup=km)
