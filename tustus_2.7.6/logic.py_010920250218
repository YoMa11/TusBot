from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional, Sequence, Tuple

import sqlite3
from pathlib import Path

# =========================================================
# עזרי DB — עמידים לשמות עמודות שונים בין גרסאות
# =========================================================

def _has_col(conn: sqlite3.Connection, table: str, col: str) -> bool:
    cur = conn.execute(f"PRAGMA table_info({table})")
    return any(r[1] == col for r in cur.fetchall())

def _pick_col(conn: sqlite3.Connection, table: str, candidates: Sequence[str]) -> Optional[str]:
    for c in candidates:
        if _has_col(conn, table, c):
            return c
    return None

def _active_predicate(conn: sqlite3.Connection, table: str = "flights") -> str:
    """
    מחזיר תנאי SQL שמייצג 'טיסות פעילות כרגע'.
    אם אין עמודת סטטוס — לא מסנן (כלומר הכל 'פעיל').
    """
    if _has_col(conn, table, "is_active"):
        return "is_active = 1"
    if _has_col(conn, table, "active"):
        return "active = 1"
    if _has_col(conn, table, "state"):
        # סכימה עשירה: 'active' ו-'new' נחשבים כפעילים לתצוגה
        return "state IN ('active','new')"
    return "1=1"

# =========================================================
# אובייקט מצב שאילתה (בשביל ה־handlers)
# =========================================================

@dataclass
class QueryState:
    """
    מייצג בחירות המשתמש במסך הראשי:
    - destinations: רשימת ערים לבחירה (או None = ללא סינון/כל היעדים)
    - date_mode: "none" | "exact" | "pm3"
    - exact_dates: רשימת YYYY-MM-DD (כש־date_mode == "exact")
    - min_seats: מספר מינימלי של מושבים (ברירת מחדל 1)
    - visibility: "active" | "new" | "dropped" | "all"
    """
    destinations: Optional[Sequence[str]] = None
    date_mode: str = "none"
    exact_dates: Optional[Sequence[str]] = None
    min_seats: int = 1
    visibility: str = "active"

# =========================================================
# מידע גרסה (לשורת הברכה)
# =========================================================

def get_version() -> str:
    """
    קורא את הקובץ VERSION אם קיים; אחרת מחזיר 'dev'.
    """
    for p in (Path.cwd() / "VERSION", Path(__file__).with_name("VERSION")):
        try:
            if p.exists():
                return p.read_text(encoding="utf-8").strip()
        except Exception:
            pass
    return "dev"

# =========================================================
# ספירות ותצוגות ל־UI
# =========================================================

def count_totals(conn: sqlite3.Connection) -> Tuple[int, int]:
    """
    מחזיר (total_active, total_all).
    עמיד לשדות is_active/active/state או בלי שדה כלל.
    """
    total_all = int(conn.execute("SELECT COUNT(*) FROM flights").fetchone()[0])
    pred = _active_predicate(conn, "flights")
    total_active = int(conn.execute(f"SELECT COUNT(*) FROM flights WHERE {pred}").fetchone()[0])
    return total_active, total_all

def list_destinations(
    conn: sqlite3.Connection,
    include_inactive: bool = True,
    limit: Optional[int] = None,
) -> List[Tuple[str, str, str, Optional[float]]]:
    """
    מחזיר רשימת יעדים לתפריט: (city, country, currency, min_price).
    - include_inactive=True => מציג גם יעדים שאינם 'פעילים' כרגע (כדי שנוכל לנטר כשיחזרו).
    - עמיד לשמות שדות שונים בין גרסאות DB.
    """
    table = "flights"
    city_col    = _pick_col(conn, table, ["dest_city", "city", "destination"]) or "destination"
    country_col = _pick_col(conn, table, ["dest_country", "country"]) or None
    cur_col     = _pick_col(conn, table, ["price_currency", "currency"]) or "currency"
    price_col   = _pick_col(conn, table, ["price_value", "price"]) or "price"

    where = "1=1"
    if not include_inactive:
        where = _active_predicate(conn, table)

    # בניית SELECT עמיד: אם אין עמודת country — נחזיר מחרוזת ריקה
    country_sel = f"COALESCE({country_col}, '')" if country_col else "''"

    sql = f"""
        SELECT
            COALESCE({city_col}, '')           AS city,
            {country_sel}                      AS country,
            COALESCE({cur_col}, '')            AS currency,
            MIN(NULLIF({price_col}, 0))        AS min_price
        FROM {table}
        WHERE {city_col} IS NOT NULL AND TRIM({city_col}) <> '' AND ({where})
        GROUP BY city, country, currency
        ORDER BY country COLLATE NOCASE ASC, city COLLATE NOCASE ASC, currency ASC
    """
    if limit:
        sql += f" LIMIT {int(limit)}"

    rows = conn.execute(sql).fetchall()

    out: List[Tuple[str, str, str, Optional[float]]] = []
    for r in rows:
        city, country, currency, min_price = r[0], r[1], r[2], r[3]
        try:
            min_price = float(min_price) if min_price is not None else None
        except Exception:
            min_price = None
        out.append((city, country, currency, min_price))
    return out

# =========================================================
# ריצה מחזורית (כדי שה־JobQueue לא יפול אם אין סקרייפר פעיל)
# =========================================================

async def run_monitor(conn: sqlite3.Connection, app: object) -> None:
    """
    גרסה 'שקטה' — לא עושה כלום כרגע (אין שינוי פונקציונלי בסקרייפר),
    ומונעת נפילות של ה־JobQueue כשמופעל monitor.
    כשתרצה – נחבר כאן את הסקרייפר בהתאם ל־html_contract ולסכימה העשירה.
    """
    return None

# ===== Destinations listing & flags (minimal additions for handlers.py) =====

def _split_city_country(dest: str) -> tuple[str, str]:
    """
    Fallback parser when DB has only 'destination' (e.g., 'אתונה - יוון').
    Returns (city, country). If no separator found, country is ''.
    """
    if not dest:
        return "", ""
    # מפריד על ' - ' או '-' או '–'
    for sep in (" - ", " – ", "-", "–"):
        if sep in dest:
            parts = [p.strip() for p in dest.split(sep, 1)]
            if len(parts) == 2:
                return parts[0], parts[1]
    return dest.strip(), ""


def list_all_destinations_with_country(conn):
    """
    Returns list of tuples: (city, country, currency, min_price, active)
    Tries rich schema first (dest_city, dest_country, price_value, currency, active),
    and falls back gracefully to older schema (destination, price, currency).
    """
    cur = conn.cursor()
    rows = []
    try:
        # סכימה עשירה
        cur.execute(
            """
            SELECT
              COALESCE(dest_city, '')       AS city,
              COALESCE(dest_country, '')    AS country,
              MAX(COALESCE(currency, ''))   AS currency,
              MIN(COALESCE(price_value, 0)) AS min_price,
              MAX(CASE WHEN COALESCE(is_active,1) IN (1,'1','true','TRUE') THEN 1 ELSE 0 END) AS active
            FROM flights
            GROUP BY city, country
            ORDER BY country, city
            """
        )
        rows = cur.fetchall()
        if rows:
            return [(r[0], r[1], r[2], r[3], r[4]) for r in rows]
    except Exception:
        pass

    # נפילה לאחור לסכימה ישנה
    try:
        cur.execute(
            """
            SELECT
              COALESCE(destination, '') AS destination,
              MAX(COALESCE(currency,'')) AS currency,
              MIN(COALESCE(price,0))     AS min_price
            FROM flights
            GROUP BY destination
            ORDER BY destination
            """
        )
        rows = cur.fetchall()
        out = []
        for dest, currency, min_price in rows:
            city, country = _split_city_country(dest or "")
            out.append((city, country, currency or "", float(min_price or 0.0), 1))
        return out
    except Exception:
        # אם גם זה נכשל—החזר רשימה ריקה ולא תפיל את הבוט
        return []


# מיפוי דגלים לפי שם מדינה (בעברית/אנגלית/ISO שכיח)
_FLAG_MAP = {
    "יוון": "🇬🇷", "Greece": "🇬🇷", "GR": "🇬🇷",
    "איטליה": "🇮🇹", "Italy": "🇮🇹", "IT": "🇮🇹",
    "אלבניה": "🇦🇱", "Albania": "🇦🇱", "AL": "🇦🇱",
    "הונגריה": "🇭🇺", "Hungary": "🇭🇺", "HU": "🇭🇺",
    "קפריסין": "🇨🇾", "Cyprus": "🇨🇾", "CY": "🇨🇾",
    "רומניה": "🇷🇴", "Romania": "🇷🇴", "RO": "🇷🇴",
    "בולגריה": "🇧🇬", "Bulgaria": "🇧🇬", "BG": "🇧🇬",
    "צרפת": "🇫🇷", "France": "🇫🇷", "FR": "🇫🇷",
    "גרמניה": "🇩🇪", "Germany": "🇩🇪", "DE": "🇩🇪",
    "ספרד": "🇪🇸", "Spain": "🇪🇸", "ES": "🇪🇸",
    "פורטוגל": "🇵🇹", "Portugal": "🇵🇹", "PT": "🇵🇹",
    "הולנד": "🇳🇱", "Netherlands": "🇳🇱", "NL": "🇳🇱",
    "בריטניה": "🇬🇧", "United Kingdom": "🇬🇧", "UK": "🇬🇧", "GB": "🇬🇧",
    "טורקיה": "🇹🇷", "Turkey": "🇹🇷", "TR": "🇹🇷",
    "ארצות הברית": "🇺🇸", "ארה\"ב": "🇺🇸", "United States": "🇺🇸", "USA": "🇺🇸", "US": "🇺🇸",
    "יפן": "🇯🇵", "Japan": "🇯🇵", "JP": "🇯🇵",
    "תאילנד": "🇹🇭", "Thailand": "🇹🇭", "TH": "🇹🇭",
    "גאורגיה": "🇬🇪", "Georgia": "🇬🇪", "GE": "🇬🇪",
    "אזרבייג'ן": "🇦🇿", "Azerbaijan": "🇦🇿", "AZ": "🇦🇿",
    # הוסף כאן מדינות נוספות לפי הצורך
}

def flag_for_country(name: str) -> str:
    """
    Returns a flag emoji for the given country name (Heb/Eng/ISO).
    Empty string if unknown.
    """
    if not name:
        return ""
    # נסיון התאמות פשוט
    name_norm = (str(name) or "").strip()
    return _FLAG_MAP.get(name_norm, "")
