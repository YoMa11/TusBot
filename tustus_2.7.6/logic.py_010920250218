from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional, Sequence, Tuple

import sqlite3
from pathlib import Path

# =========================================================
# ×¢×–×¨×™ DB â€” ×¢××™×“×™× ×œ×©××•×ª ×¢××•×“×•×ª ×©×•× ×™× ×‘×™×Ÿ ×’×¨×¡××•×ª
# =========================================================

def _has_col(conn: sqlite3.Connection, table: str, col: str) -> bool:
    cur = conn.execute(f"PRAGMA table_info({table})")
    return any(r[1] == col for r in cur.fetchall())

def _pick_col(conn: sqlite3.Connection, table: str, candidates: Sequence[str]) -> Optional[str]:
    for c in candidates:
        if _has_col(conn, table, c):
            return c
    return None

def _active_predicate(conn: sqlite3.Connection, table: str = "flights") -> str:
    """
    ××—×–×™×¨ ×ª× ××™ SQL ×©××™×™×¦×’ '×˜×™×¡×•×ª ×¤×¢×™×œ×•×ª ×›×¨×’×¢'.
    ×× ××™×Ÿ ×¢××•×“×ª ×¡×˜×˜×•×¡ â€” ×œ× ××¡× ×Ÿ (×›×œ×•××¨ ×”×›×œ '×¤×¢×™×œ').
    """
    if _has_col(conn, table, "is_active"):
        return "is_active = 1"
    if _has_col(conn, table, "active"):
        return "active = 1"
    if _has_col(conn, table, "state"):
        # ×¡×›×™××” ×¢×©×™×¨×”: 'active' ×•-'new' × ×—×©×‘×™× ×›×¤×¢×™×œ×™× ×œ×ª×¦×•×’×”
        return "state IN ('active','new')"
    return "1=1"

# =========================================================
# ××•×‘×™×™×§×˜ ××¦×‘ ×©××™×œ×ª×” (×‘×©×‘×™×œ ×”Ö¾handlers)
# =========================================================

@dataclass
class QueryState:
    """
    ××™×™×¦×’ ×‘×—×™×¨×•×ª ×”××©×ª××© ×‘××¡×š ×”×¨××©×™:
    - destinations: ×¨×©×™××ª ×¢×¨×™× ×œ×‘×—×™×¨×” (××• None = ×œ×œ× ×¡×™× ×•×Ÿ/×›×œ ×”×™×¢×“×™×)
    - date_mode: "none" | "exact" | "pm3"
    - exact_dates: ×¨×©×™××ª YYYY-MM-DD (×›×©Ö¾date_mode == "exact")
    - min_seats: ××¡×¤×¨ ××™× ×™××œ×™ ×©×œ ××•×©×‘×™× (×‘×¨×™×¨×ª ××—×“×œ 1)
    - visibility: "active" | "new" | "dropped" | "all"
    """
    destinations: Optional[Sequence[str]] = None
    date_mode: str = "none"
    exact_dates: Optional[Sequence[str]] = None
    min_seats: int = 1
    visibility: str = "active"

# =========================================================
# ××™×“×¢ ×’×¨×¡×” (×œ×©×•×¨×ª ×”×‘×¨×›×”)
# =========================================================

def get_version() -> str:
    """
    ×§×•×¨× ××ª ×”×§×•×‘×¥ VERSION ×× ×§×™×™×; ××—×¨×ª ××—×–×™×¨ 'dev'.
    """
    for p in (Path.cwd() / "VERSION", Path(__file__).with_name("VERSION")):
        try:
            if p.exists():
                return p.read_text(encoding="utf-8").strip()
        except Exception:
            pass
    return "dev"

# =========================================================
# ×¡×¤×™×¨×•×ª ×•×ª×¦×•×’×•×ª ×œÖ¾UI
# =========================================================

def count_totals(conn: sqlite3.Connection) -> Tuple[int, int]:
    """
    ××—×–×™×¨ (total_active, total_all).
    ×¢××™×“ ×œ×©×“×•×ª is_active/active/state ××• ×‘×œ×™ ×©×“×” ×›×œ×œ.
    """
    total_all = int(conn.execute("SELECT COUNT(*) FROM flights").fetchone()[0])
    pred = _active_predicate(conn, "flights")
    total_active = int(conn.execute(f"SELECT COUNT(*) FROM flights WHERE {pred}").fetchone()[0])
    return total_active, total_all

def list_destinations(
    conn: sqlite3.Connection,
    include_inactive: bool = True,
    limit: Optional[int] = None,
) -> List[Tuple[str, str, str, Optional[float]]]:
    """
    ××—×–×™×¨ ×¨×©×™××ª ×™×¢×“×™× ×œ×ª×¤×¨×™×˜: (city, country, currency, min_price).
    - include_inactive=True => ××¦×™×’ ×’× ×™×¢×“×™× ×©××™× × '×¤×¢×™×œ×™×' ×›×¨×’×¢ (×›×“×™ ×©× ×•×›×œ ×œ× ×˜×¨ ×›×©×™×—×–×¨×•).
    - ×¢××™×“ ×œ×©××•×ª ×©×“×•×ª ×©×•× ×™× ×‘×™×Ÿ ×’×¨×¡××•×ª DB.
    """
    table = "flights"
    city_col    = _pick_col(conn, table, ["dest_city", "city", "destination"]) or "destination"
    country_col = _pick_col(conn, table, ["dest_country", "country"]) or None
    cur_col     = _pick_col(conn, table, ["price_currency", "currency"]) or "currency"
    price_col   = _pick_col(conn, table, ["price_value", "price"]) or "price"

    where = "1=1"
    if not include_inactive:
        where = _active_predicate(conn, table)

    # ×‘× ×™×™×ª SELECT ×¢××™×“: ×× ××™×Ÿ ×¢××•×“×ª country â€” × ×—×–×™×¨ ××—×¨×•×–×ª ×¨×™×§×”
    country_sel = f"COALESCE({country_col}, '')" if country_col else "''"

    sql = f"""
        SELECT
            COALESCE({city_col}, '')           AS city,
            {country_sel}                      AS country,
            COALESCE({cur_col}, '')            AS currency,
            MIN(NULLIF({price_col}, 0))        AS min_price
        FROM {table}
        WHERE {city_col} IS NOT NULL AND TRIM({city_col}) <> '' AND ({where})
        GROUP BY city, country, currency
        ORDER BY country COLLATE NOCASE ASC, city COLLATE NOCASE ASC, currency ASC
    """
    if limit:
        sql += f" LIMIT {int(limit)}"

    rows = conn.execute(sql).fetchall()

    out: List[Tuple[str, str, str, Optional[float]]] = []
    for r in rows:
        city, country, currency, min_price = r[0], r[1], r[2], r[3]
        try:
            min_price = float(min_price) if min_price is not None else None
        except Exception:
            min_price = None
        out.append((city, country, currency, min_price))
    return out

# =========================================================
# ×¨×™×¦×” ××—×–×•×¨×™×ª (×›×“×™ ×©×”Ö¾JobQueue ×œ× ×™×¤×•×œ ×× ××™×Ÿ ×¡×§×¨×™×™×¤×¨ ×¤×¢×™×œ)
# =========================================================

async def run_monitor(conn: sqlite3.Connection, app: object) -> None:
    """
    ×’×¨×¡×” '×©×§×˜×”' â€” ×œ× ×¢×•×©×” ×›×œ×•× ×›×¨×’×¢ (××™×Ÿ ×©×™× ×•×™ ×¤×•× ×§×¦×™×•× ×œ×™ ×‘×¡×§×¨×™×™×¤×¨),
    ×•××•× ×¢×ª × ×¤×™×œ×•×ª ×©×œ ×”Ö¾JobQueue ×›×©××•×¤×¢×œ monitor.
    ×›×©×ª×¨×¦×” â€“ × ×—×‘×¨ ×›××Ÿ ××ª ×”×¡×§×¨×™×™×¤×¨ ×‘×”×ª×× ×œÖ¾html_contract ×•×œ×¡×›×™××” ×”×¢×©×™×¨×”.
    """
    return None

# ===== Destinations listing & flags (minimal additions for handlers.py) =====

def _split_city_country(dest: str) -> tuple[str, str]:
    """
    Fallback parser when DB has only 'destination' (e.g., '××ª×•× ×” - ×™×•×•×Ÿ').
    Returns (city, country). If no separator found, country is ''.
    """
    if not dest:
        return "", ""
    # ××¤×¨×™×“ ×¢×œ ' - ' ××• '-' ××• 'â€“'
    for sep in (" - ", " â€“ ", "-", "â€“"):
        if sep in dest:
            parts = [p.strip() for p in dest.split(sep, 1)]
            if len(parts) == 2:
                return parts[0], parts[1]
    return dest.strip(), ""


def list_all_destinations_with_country(conn):
    """
    Returns list of tuples: (city, country, currency, min_price, active)
    Tries rich schema first (dest_city, dest_country, price_value, currency, active),
    and falls back gracefully to older schema (destination, price, currency).
    """
    cur = conn.cursor()
    rows = []
    try:
        # ×¡×›×™××” ×¢×©×™×¨×”
        cur.execute(
            """
            SELECT
              COALESCE(dest_city, '')       AS city,
              COALESCE(dest_country, '')    AS country,
              MAX(COALESCE(currency, ''))   AS currency,
              MIN(COALESCE(price_value, 0)) AS min_price,
              MAX(CASE WHEN COALESCE(is_active,1) IN (1,'1','true','TRUE') THEN 1 ELSE 0 END) AS active
            FROM flights
            GROUP BY city, country
            ORDER BY country, city
            """
        )
        rows = cur.fetchall()
        if rows:
            return [(r[0], r[1], r[2], r[3], r[4]) for r in rows]
    except Exception:
        pass

    # × ×¤×™×œ×” ×œ××—×•×¨ ×œ×¡×›×™××” ×™×©× ×”
    try:
        cur.execute(
            """
            SELECT
              COALESCE(destination, '') AS destination,
              MAX(COALESCE(currency,'')) AS currency,
              MIN(COALESCE(price,0))     AS min_price
            FROM flights
            GROUP BY destination
            ORDER BY destination
            """
        )
        rows = cur.fetchall()
        out = []
        for dest, currency, min_price in rows:
            city, country = _split_city_country(dest or "")
            out.append((city, country, currency or "", float(min_price or 0.0), 1))
        return out
    except Exception:
        # ×× ×’× ×–×” × ×›×©×œâ€”×”×—×–×¨ ×¨×©×™××” ×¨×™×§×” ×•×œ× ×ª×¤×™×œ ××ª ×”×‘×•×˜
        return []


# ××™×¤×•×™ ×“×’×œ×™× ×œ×¤×™ ×©× ××“×™× ×” (×‘×¢×‘×¨×™×ª/×× ×’×œ×™×ª/ISO ×©×›×™×—)
_FLAG_MAP = {
    "×™×•×•×Ÿ": "ğŸ‡¬ğŸ‡·", "Greece": "ğŸ‡¬ğŸ‡·", "GR": "ğŸ‡¬ğŸ‡·",
    "××™×˜×œ×™×”": "ğŸ‡®ğŸ‡¹", "Italy": "ğŸ‡®ğŸ‡¹", "IT": "ğŸ‡®ğŸ‡¹",
    "××œ×‘× ×™×”": "ğŸ‡¦ğŸ‡±", "Albania": "ğŸ‡¦ğŸ‡±", "AL": "ğŸ‡¦ğŸ‡±",
    "×”×•× ×’×¨×™×”": "ğŸ‡­ğŸ‡º", "Hungary": "ğŸ‡­ğŸ‡º", "HU": "ğŸ‡­ğŸ‡º",
    "×§×¤×¨×™×¡×™×Ÿ": "ğŸ‡¨ğŸ‡¾", "Cyprus": "ğŸ‡¨ğŸ‡¾", "CY": "ğŸ‡¨ğŸ‡¾",
    "×¨×•×× ×™×”": "ğŸ‡·ğŸ‡´", "Romania": "ğŸ‡·ğŸ‡´", "RO": "ğŸ‡·ğŸ‡´",
    "×‘×•×œ×’×¨×™×”": "ğŸ‡§ğŸ‡¬", "Bulgaria": "ğŸ‡§ğŸ‡¬", "BG": "ğŸ‡§ğŸ‡¬",
    "×¦×¨×¤×ª": "ğŸ‡«ğŸ‡·", "France": "ğŸ‡«ğŸ‡·", "FR": "ğŸ‡«ğŸ‡·",
    "×’×¨×× ×™×”": "ğŸ‡©ğŸ‡ª", "Germany": "ğŸ‡©ğŸ‡ª", "DE": "ğŸ‡©ğŸ‡ª",
    "×¡×¤×¨×“": "ğŸ‡ªğŸ‡¸", "Spain": "ğŸ‡ªğŸ‡¸", "ES": "ğŸ‡ªğŸ‡¸",
    "×¤×•×¨×˜×•×’×œ": "ğŸ‡µğŸ‡¹", "Portugal": "ğŸ‡µğŸ‡¹", "PT": "ğŸ‡µğŸ‡¹",
    "×”×•×œ× ×“": "ğŸ‡³ğŸ‡±", "Netherlands": "ğŸ‡³ğŸ‡±", "NL": "ğŸ‡³ğŸ‡±",
    "×‘×¨×™×˜× ×™×”": "ğŸ‡¬ğŸ‡§", "United Kingdom": "ğŸ‡¬ğŸ‡§", "UK": "ğŸ‡¬ğŸ‡§", "GB": "ğŸ‡¬ğŸ‡§",
    "×˜×•×¨×§×™×”": "ğŸ‡¹ğŸ‡·", "Turkey": "ğŸ‡¹ğŸ‡·", "TR": "ğŸ‡¹ğŸ‡·",
    "××¨×¦×•×ª ×”×‘×¨×™×ª": "ğŸ‡ºğŸ‡¸", "××¨×”\"×‘": "ğŸ‡ºğŸ‡¸", "United States": "ğŸ‡ºğŸ‡¸", "USA": "ğŸ‡ºğŸ‡¸", "US": "ğŸ‡ºğŸ‡¸",
    "×™×¤×Ÿ": "ğŸ‡¯ğŸ‡µ", "Japan": "ğŸ‡¯ğŸ‡µ", "JP": "ğŸ‡¯ğŸ‡µ",
    "×ª××™×œ× ×“": "ğŸ‡¹ğŸ‡­", "Thailand": "ğŸ‡¹ğŸ‡­", "TH": "ğŸ‡¹ğŸ‡­",
    "×’××•×¨×’×™×”": "ğŸ‡¬ğŸ‡ª", "Georgia": "ğŸ‡¬ğŸ‡ª", "GE": "ğŸ‡¬ğŸ‡ª",
    "××–×¨×‘×™×™×’'×Ÿ": "ğŸ‡¦ğŸ‡¿", "Azerbaijan": "ğŸ‡¦ğŸ‡¿", "AZ": "ğŸ‡¦ğŸ‡¿",
    # ×”×•×¡×£ ×›××Ÿ ××“×™× ×•×ª × ×•×¡×¤×•×ª ×œ×¤×™ ×”×¦×•×¨×š
}

def flag_for_country(name: str) -> str:
    """
    Returns a flag emoji for the given country name (Heb/Eng/ISO).
    Empty string if unknown.
    """
    if not name:
        return ""
    # × ×¡×™×•×Ÿ ×”×ª×××•×ª ×¤×©×•×˜
    name_norm = (str(name) or "").strip()
    return _FLAG_MAP.get(name_norm, "")
