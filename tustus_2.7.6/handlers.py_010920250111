# handlers.py
from __future__ import annotations
from typing import Dict, Any, Tuple, List, Optional
from datetime import date, datetime, timezone, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
import db
import logic
import telegram_view as tv

# ===== In-memory UI state per chat =====
_STATE: Dict[int, Dict[str, Any]] = {}

def _get_state(chat_id: int) -> Dict[str, Any]:
    st = _STATE.get(chat_id)
    if st is None:
        st = {
            "destinations": set(),   # set of city names, empty -> all
            "date_mode": "none",     # none|exact|plusminus
            "date_exact": None,      # YYYY-MM-DD
            "min_seats": 5,          # default 5 if unknown
            "visibility": "active",  # active|new|removed
            "page": 0,
        }
        _STATE[chat_id] = st
    return st

def _state_line(st: Dict[str, Any]) -> str:
    parts = []
    if not st["destinations"] or "*" in st["destinations"]:
        parts.append("×›×œ ×”×™×¢×“×™×")
    else:
        parts.append("×™×¢×“: " + ", ".join(sorted(st["destinations"]))[:40])
    dm = st["date_mode"]
    if dm == "none":
        parts.append("×œ×œ× ×ª××¨×™×š")
    elif dm == "exact" and st["date_exact"]:
        parts.append(f"×ª××¨×™×š: {st['date_exact']}")
    elif dm == "plusminus" and st["date_exact"]:
        parts.append(f"×ª××¨×™×š Â±3: {st['date_exact']}")
    parts.append(f"××•×©×‘×™× ××™× ×³: {st['min_seats']}")
    vis_map = {"active":"×§×™×™××•×ª","new":"×—×“×©×•×ª","removed":"×™×¨×“×•"}
    parts.append(f"× ×¨××•×ª: {vis_map.get(st['visibility'],'×§×™×™××•×ª')}")
    return " | ".join(parts)

def _dates_for_ui() -> List[date]:
    today = date.today()
    return [today + timedelta(days=i) for i in range(0, 7)]

def _build_dest_block(conn, st: Dict[str, Any]) -> List[List[InlineKeyboardButton]]:
    options: List[Tuple[str, str, bool]] = []
    # "All destinations"
    options.append(("×›×œ ×”×™×¢×“×™× ğŸŒ", "dst:*", (not st["destinations"] or "*" in st["destinations"])))
    for city, cur, price in logic.list_destinations(conn, limit=10):
        selected = (city in st["destinations"]) and "*" not in st["destinations"]
        price_str = tv._fmt_price(cur or "", price)  # use helper
        label = f"{city}" if not price_str else f"{city} Â· {price_str}"
        options.append((label, f"dst:{city}", selected))
    return tv.build_destinations_row(options)

def _build_dates_block(st: Dict[str, Any]) -> List[List[InlineKeyboardButton]]:
    dates = _dates_for_ui()
    date_labels: List[Tuple[str, str, bool]] = []
    # first chip is "×œ×œ×"
    no_sel = (st["date_mode"] == "none")
    date_labels.append(("×œ×œ× âœ…" if no_sel else "×œ×œ×", "date:none", no_sel))
    # actual dates (format dd/mm)
    for d in dates:
        dd = d.strftime("%d/%m")
        selected = (st["date_exact"] == d.isoformat()) and (st["date_mode"] != "none")
        date_labels.append((dd, f"date:{d.isoformat()}", selected))
    # modes
    modes = [
        ("××“×•×™×§", "datemode:exact", st["date_mode"] == "exact"),
        ("×™××™× Â±3", "datemode:plusminus", st["date_mode"] == "plusminus"),
    ]
    return tv.build_dates_block(date_labels, modes)

def _build_seats_block(st: Dict[str, Any]) -> List[List[InlineKeyboardButton]]:
    vals = []
    for n in [1,2,3,4,5]:
        vals.append((str(n), f"seats:{n}", st["min_seats"] == n))
    return tv.build_seats_row(vals)

def _build_visibility_block(st: Dict[str, Any]) -> List[List[InlineKeyboardButton]]:
    vals = [
        ("×—×“×©×•×ª ğŸ†•", "vis:new", st["visibility"]=="new"),
        ("×§×™×™××•×ª âœ…", "vis:active", st["visibility"]=="active"),
        ("×™×¨×“×• â›”ï¸", "vis:removed", st["visibility"]=="removed"),
    ]
    return tv.build_visibility_row(vals)

def _build_main_screen(conn, st: Dict[str, Any]) -> Tuple[str, InlineKeyboardMarkup]:
    # header
    total_active, total_all = logic.count_totals(conn)
    text = tv.build_header_text(total_active, total_all, _state_line(st))
    # blocks
    blocks: List[List[List[InlineKeyboardButton]]] = []
    blocks.append(_build_dest_block(conn, st))
    blocks.append(_build_dates_block(st))
    blocks.append(_build_seats_block(st))
    blocks.append(_build_visibility_block(st))
    # footer
    blocks.append(tv.build_footer_row())
    km = tv.build_keyboard(blocks)
    return text, km

async def handle_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.effective_chat.id
    st = _get_state(chat_id)
    conn = db.get_conn()
    text, km = _build_main_screen(conn, st)
    await update.effective_message.reply_text(text, reply_markup=km)

def _toggle_dest(st: Dict[str, Any], city: str) -> None:
    if city == "*":
        st["destinations"] = {"*"}
        return
    if "*" in st["destinations"]:
        st["destinations"].remove("*")
    if city in st["destinations"]:
        st["destinations"].remove(city)
    else:
        st["destinations"].add(city)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query
    await q.answer()
    data = (q.data or "")
    chat_id = update.effective_chat.id
    st = _get_state(chat_id)

    if data.startswith("dst:"):
        city = data.split(":",1)[1]
        _toggle_dest(st, city)
    elif data.startswith("date:"):
        v = data.split(":",1)[1]
        if v == "none":
            st["date_mode"] = "none"; st["date_exact"] = None
        else:
            st["date_exact"] = v
            if st["date_mode"] == "none":
                st["date_mode"] = "exact"
    elif data.startswith("datemode:"):
        st["date_mode"] = data.split(":",1)[1]
    elif data.startswith("seats:"):
        st["min_seats"] = int(data.split(":",1)[1])
    elif data.startswith("vis:"):
        st["visibility"] = data.split(":",1)[1]
    elif data == "act:summary":
        conn = db.get_conn()
        qst = logic.QueryState(
            destinations=list(st["destinations"]) if st["destinations"] else None,
            date_mode=st["date_mode"],
            date_exact=datetime.fromisoformat(st["date_exact"]).date() if st["date_exact"] else None,
            min_seats=st["min_seats"],
            visibility=st["visibility"]
        )
        counts = logic.counts_by_destination(conn, qst)[:25]
        if counts:
            lines = ["ğŸ“Š ×¡×™×›×•× ×™×¢×“×™× (Top 25):"]
            for city, c in counts:
                lines.append(f"â€¢ {city}: {c}")
            await q.message.reply_text("\n".join(lines))
        else:
            await q.message.reply_text("××™×Ÿ ×ª×•×¦××•×ª ×œ×ª×¦×•×’×”.")
    elif data == "act:refresh":
        pass  # no-op; will re-render

    # re-render
    conn = db.get_conn()
    text, km = _build_main_screen(conn, st)
    old_text = q.message.text or ""
    if old_text == text:
        text += "\u2063"  # avoid "Message is not modified"
    await q.edit_message_text(text, reply_markup=km)
