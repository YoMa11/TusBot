from __future__ import annotations
import re
import requests
from bs4 import BeautifulSoup
from typing import Dict, List, Tuple
import db
import logging

log = logging.getLogger(__name__)

PRICE_RE = re.compile(r'([$\u20AA])\s*([0-9]+(?:\.[0-9]+)?)')  # $ / ₪

def _split_dest(destination: str) -> Tuple[str, str]:
    # "אתונה - יוון" -> ("אתונה","יוון")
    if not destination:
        return "", ""
    parts = [p.strip() for p in destination.split("-")]
    city = parts[0] if parts else ""
    country = parts[1] if len(parts) > 1 else ""
    return city, country

def _txt(el) -> str:
    return (el.get_text(" ", strip=True) if el else "").strip()

def _attr(el, name, default="") -> str:
    return el.get(name) if el and el.has_attr(name) else default

def _parse_price_text(s: str) -> Tuple[str, float | None]:
    """Extract currency symbol and numeric value from '$150' / '₪399'."""
    m = PRICE_RE.search(s or "")
    if not m:
        return "", None
    sym = m.group(1)
    try:
        val = float(m.group(2))
    except ValueError:
        val = None
    # derive currency code from symbol if needed
    cur = "USD" if sym == "$" else "ILS" if sym == "\u20AA" else ""
    return cur, val

def fetch_html(url: str, timeout: int = 15) -> str:
    headers = {"User-Agent": "Mozilla/5.0 (compatible; TustusBot/1.0)"}
    r = requests.get(url, timeout=timeout, headers=headers)
    r.raise_for_status()
    return r.text

def parse_items(html: str) -> List[Dict]:
    soup = BeautifulSoup(html, "lxml")
    items: List[Dict] = []
    for box in soup.select(".show_item"):
        d: Dict = {}

        # מזהים ואפיונים כלליים
        d["item_id"]      = _attr(box, "data_ga_item_id") or _attr(box, "ite_item")
        d["selapp_item"]  = _attr(box, "ite_selappitem")
        d["category"]     = _attr(box, "category")
        d["provider"]     = _attr(box, "data_ga_item_category4")
        d["affiliation"]  = _attr(box, "data_ga_affiliation")
        d["promo_category"] = _attr(box, "data_ga_item_category")
        d["destination"]  = _attr(box, "data_ga_item_name") or _attr(box, "con_desc")

        d["trip_title"]   = _txt(box.select_one(".show_item_name"))

        # מחיר/מטבע
        price_text_el = box.select_one(".show_item_total_price")
        d["price_text"] = _txt(price_text_el)
        # מחיר ריאלי:
        data_num_price = _attr(box, "data_number_ga_price")
        if data_num_price:
            try:
                d["price"] = float(data_num_price)
            except ValueError:
                d["price"] = None
        else:
            cur_from_text, val_from_text = _parse_price_text(d["price_text"])
            d["price"] = val_from_text
            # מטבע
            d["currency"] = _attr(box, "data_ga_currency") or (cur_from_text or "")
        if "currency" not in d or not d["currency"]:
            d["currency"] = _attr(box, "data_ga_currency") or ""

        # תמונה ובאדג'
        d["img_url"]     = _attr(box.select_one(".show_item_img img"), "src")
        d["badge_text"]  = _txt(box.select_one(".spcial_message_bottom"))

        # פרטי הלוך
        go   = box.select_one(".flight_go")
        g_fr = go.select_one(".from") if go else None
        g_to = go.select_one(".to")   if go else None
        d["out_from_city"] = _txt(g_fr.select_one(".text-gray")) if g_fr else ""
        d["out_from_time"] = _txt(g_fr.select_one(".flight_hourTime")) if g_fr else ""
        d["out_from_date"] = _txt(g_fr.select_one(".text-gray + .flight_hourTime"))  # ליתר בטחון
        # לעתים התאריך באלמנט השלישי באותו בלוק:
        if not d["out_from_date"] and g_fr:
            gs = g_fr.select(".text-gray")
            d["out_from_date"] = _txt(gs[1]) if len(gs) > 1 else ""

        d["out_to_city"]  = _txt(g_to.select_one(".text-gray")) if g_to else ""
        d["out_to_time"]  = _txt(g_to.select_one(".flight_hourTime")) if g_to else ""
        d["out_to_date"]  = ""
        if g_to:
            gs = g_to.select(".text-gray")
            d["out_to_date"] = _txt(gs[1]) if len(gs) > 1 else ""

        # פרטי חזור
        back   = box.select_one(".flight_back")
        b_fr = back.select_one(".from") if back else None
        b_to = back.select_one(".to")   if back else None
        d["back_from_city"] = _txt(b_fr.select_one(".text-gray")) if b_fr else ""
        d["back_from_time"] = _txt(b_fr.select_one(".flight_hourTime")) if b_fr else ""
        d["back_from_date"] = ""
        if b_fr:
            gs = b_fr.select(".text-gray")
            d["back_from_date"] = _txt(gs[1]) if len(gs) > 1 else ""

        d["back_to_city"]  = _txt(b_to.select_one(".text-gray")) if b_to else ""
        d["back_to_time"]  = _txt(b_to.select_one(".flight_hourTime")) if b_to else ""
        d["back_to_date"]  = ""
        if b_to:
            gs = b_to.select(".text-gray")
            d["back_to_date"] = _txt(gs[1]) if len(gs) > 1 else ""

        # הערות/קישוטים
        d["note"]      = _txt(box.select_one(".flight_note"))
        d["more_like"] = _txt(box.select_one(".more_like_this"))

        # יעד מפוצל (עיר/מדינה)
        city, country = _split_dest(d.get("destination",""))
        d["dest_city"] = city
        d["dest_country"] = country

        # URL להזמנה (אם יש)
        d["url"] = ""

        # ודא מפתח לוגי
        if not (d["item_id"] or d["selapp_item"]):
            # אם אין מפתח מהאתר – נייצר hash פשוט מהכותרת+מחיר כדי לא לאבד נתון
            d["item_id"] = f"auto-{abs(hash(d['trip_title'] + d.get('price_text','')))}"
            d["selapp_item"] = d["item_id"]

        items.append(d)
    return items

def monitor_job(conn, app) -> tuple[int, int, int]:
    """
    שגרה מרכזית: מורידה HTML, מפרקת, מעדכנת DB.
    מחזירה (inserted, updated, total_active).
    """
    from config import URL as SRC_URL  # לא נוגעים בשם ולא בקובץ
    html = fetch_html(SRC_URL)
    items = parse_items(html)

    # מסמן הכל כלא־פעיל, ואז מפרסם את מה שנמצא כרגע באתר – כפעיל
    db.mark_all_inactive(conn)
    ins, upd = db.upsert_batch(conn, items)
    total_active = conn.execute("SELECT COUNT(*) AS c FROM flights WHERE is_active=1;").fetchone()["c"]
    log.info("monitor_job: parsed=%d, inserted=%d, updated=%d, active=%d", len(items), ins, upd, total_active)
    return ins, upd, total_active

async def run_monitor(conn, app) -> None:
    # כאן נשאיר סינכרוני (requests + sqlite) כדי להימנע מסוגיית thread-affinity.
    try:
        monitor_job(conn, app)
    except Exception as e:
        log.exception("run_monitor error: %s", e)
