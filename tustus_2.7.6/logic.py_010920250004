# logic.py
from __future__ import annotations
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone, date
import re
import sqlite3

ACTIVE_WINDOW_MIN = 180  # consider active if seen in last N minutes
NEW_WINDOW_MIN = 60      # consider new if first seen within last N minutes

@dataclass
class QueryState:
    destinations: Optional[List[str]] = None  # None -> all
    date_mode: str = "none"  # none | exact | plusminus
    date_exact: Optional[date] = None
    min_seats: int = 1
    visibility: str = "active"  # active|new|removed|all

def _parse_seats(badge_text: Optional[str]) -> int:
    if not badge_text:
        return 5
    m = re.search(r"(\d+)", badge_text)
    if m:
        try:
            return int(m.group(1))
        except Exception:
            return 5
    return 5

def _utcnow() -> datetime:
    return datetime.now(timezone.utc)

def _date_from_str(s: str) -> Optional[date]:
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except Exception:
        return None

def list_destinations(conn: sqlite3.Connection, limit: int = 12, with_prices: bool = True) -> List[Tuple[str, Optional[str], Optional[float]]]:
    sql = "SELECT dest_city, currency, price FROM flights WHERE dest_city IS NOT NULL AND dest_city<>'' GROUP BY dest_city ORDER BY MIN(price) NULLS LAST, dest_city ASC"
    try:
        rows = conn.execute(sql).fetchall()
    except Exception:
        # fallback for sqlite without NULLS LAST syntax
        sql = "SELECT dest_city, currency, MIN(price) as price FROM flights WHERE COALESCE(dest_city,'')<>'' GROUP BY dest_city ORDER BY (price IS NULL), price, dest_city"
        rows = conn.execute(sql).fetchall()
    out: List[Tuple[str, Optional[str], Optional[float]]] = []
    for r in rows[:limit]:
        city = r[0]
        cur = r[1]
        price = r[2]
        out.append((city, cur, float(price) if price is not None else None))
    return out

def count_totals(conn: sqlite3.Connection) -> Tuple[int, int]:
    now = _utcnow()
    cutoff_active = now - timedelta(minutes=ACTIVE_WINDOW_MIN)
    total_all = conn.execute("SELECT COUNT(*) FROM flights").fetchone()[0]
    total_active = conn.execute("SELECT COUNT(*) FROM flights WHERE datetime(last_seen) >= datetime(?)", (cutoff_active.astimezone(timezone.utc).strftime('%Y-%m-%d %H:%M:%S'),)).fetchone()[0]
    return total_active, total_all

def _status_where_clause(vis: str) -> Tuple[str, Tuple]:
    now = _utcnow()
    cutoff_active = now - timedelta(minutes=ACTIVE_WINDOW_MIN)
    cutoff_new = now - timedelta(minutes=NEW_WINDOW_MIN)
    if vis == "active":
        return ("datetime(last_seen) >= datetime(?)", (cutoff_active.astimezone(timezone.utc).strftime('%Y-%m-%d %H:%M:%S'),))
    if vis == "new":
        # prefer first_seen if exists; otherwise last_seen
        return ("datetime(COALESCE(first_seen, last_seen)) >= datetime(?)", (cutoff_new.astimezone(timezone.utc).strftime('%Y-%m-%d %H:%M:%S'),))
    if vis == "removed":
        return ("datetime(last_seen) < datetime(?)", (cutoff_active.astimezone(timezone.utc).strftime('%Y-%m-%d %H:%M:%S'),))
    return ("1=1", ())

def _date_predicate(mode: str, exact: Optional[date]) -> Tuple[str, Tuple]:
    if mode == "none" or not exact:
        return ("1=1", ())
    if mode == "exact":
        return ("date(out_date) = ?", (exact.isoformat(),))
    if mode == "plusminus":
        return ("date(out_date) BETWEEN date(?, '-3 day') AND date(?, '+3 day')", (exact.isoformat(), exact.isoformat()))
    return ("1=1", ())

def query_offers(conn: sqlite3.Connection, st: QueryState, limit: int = 10) -> List[Dict[str, Any]]:
    where = []
    args: List[Any] = []
    # status
    w, a = _status_where_clause(st.visibility)
    where.append(w); args += list(a)
    # destinations
    if st.destinations and len(st.destinations) > 0 and "*" not in st.destinations:
        where.append("dest_city IN (%s)" % ",".join("?" for _ in st.destinations))
        args += st.destinations
    # date
    w,a = _date_predicate(st.date_mode, st.date_exact)
    where.append(w); args += list(a)
    # seats via badge_text parsing (>= min) — נסנן בפייתון במקרה שאין פונקציית REGEXP ב-SQLite
    where.append("(1=1)")

    sql = "SELECT item_id, dest_city, dest_country, currency, price, badge_text, out_date, out_time, back_date, back_time, last_seen, first_seen FROM flights WHERE " + " AND ".join(where) + " ORDER BY price ASC NULLS LAST, last_seen DESC LIMIT ?"
    try:
        rows = conn.execute(sql, (*args, limit)).fetchall()
    except Exception:
        # fallback without NULLS LAST
        sql = "SELECT item_id, dest_city, dest_country, currency, price, badge_text, out_date, out_time, back_date, back_time, last_seen, first_seen FROM flights WHERE " + " AND ".join(where[:-1]) + " ORDER BY (price IS NULL), price, last_seen DESC LIMIT ?"
        rows = conn.execute(sql, (*args[:-1], limit)).fetchall()

    out: List[Dict[str, Any]] = []
    for r in rows:
        d = {
            "item_id": r[0],
            "city": r[1] or "",
            "country": r[2] or "",
            "currency": r[3] or "",
            "price": float(r[4]) if r[4] is not None else None,
            "badge_text": r[5] or "",
            "out_date": r[6],
            "out_time": r[7],
            "back_date": r[8],
            "back_time": r[9],
            "last_seen": r[10],
            "first_seen": r[11],
        }
        seats = _parse_seats(d["badge_text"])
        if seats >= st.min_seats:
            out.append(d)
    return out

def counts_by_destination(conn: sqlite3.Connection, st: QueryState) -> List[Tuple[str, int]]:
    where = []
    args: List[Any] = []
    # status
    w,a = _status_where_clause(st.visibility)
    where.append(w); args += list(a)
    # date
    w,a = _date_predicate(st.date_mode, st.date_exact)
    where.append(w); args += list(a)
    sql = "SELECT dest_city, COUNT(*) FROM flights WHERE " + " AND ".join(where) + " GROUP BY dest_city ORDER BY COUNT(*) DESC, dest_city"
    rows = conn.execute(sql, tuple(args)).fetchall()
    return [(r[0] or "—", int(r[1])) for r in rows]
