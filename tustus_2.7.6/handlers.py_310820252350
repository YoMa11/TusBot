from __future__ import annotations

import asyncio
import datetime as dt
import sqlite3
from typing import Dict, List, Tuple, Optional

from telegram import (
    Update,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from telegram.ext import ContextTypes

import db  # ×œ× × ×•×’×¢ ×‘×§×•×‘×¥ ×”×–×” â€“ ×¨×§ ××©×ª××© ×‘- db.get_conn()

# ========= ×ª×¦×•×’×” =========
from telegram_view import (
    format_greeting,
    summarize_selection,
    format_price,
)

INVISIBLE = "\u2063"  # ×œ×× ×™×¢×ª "Message is not modified"
MAX_DESTS_PER_PAGE = 12   # ×›××•×ª ×›×¤×ª×•×¨×™ ×™×¢×“×™× ×‘×•-×–×× ×™×ª
DEST_COLS = 2             # ×©× ×™ ×˜×•×¨×™× ×œ×›×¤×ª×•×¨×™ ×”×™×¢×“×™×
NEW_WINDOW_MINUTES = 60   # "×—×“×©×•×ª" = × ×›× ×¡×• ×‘×©×¢×” ×”××—×¨×•× ×”

# ========== ×¢×•×–×¨×™× ×œ-DB ==========
def _fetch_destinations(conn: sqlite3.Connection, offset: int = 0, limit: int = MAX_DESTS_PER_PAGE
                        ) -> List[sqlite3.Row]:
    """
    ××‘×™× ×¨×©×™××ª ×™×¢×“×™× (×¢×™×¨+××“×™× ×”) ×¢× ××—×™×¨ ××™× ×™××œ×™ ×œ×”×¦×’×” ×‘×›×¤×ª×•×¨.
    ×¢×•×‘×“ ×¢×œ ×”×¡×›×™××” ×”×¢×©×™×¨×”: dest_city, dest_country, price, currency.
    """
    sql = """
    SELECT
        COALESCE(dest_city,'')   AS city,
        COALESCE(dest_country,'') AS country,
        MIN(price)               AS min_price,
        MAX(currency)            AS currency
    FROM flights
    GROUP BY dest_city, dest_country
    ORDER BY country, city
    LIMIT ? OFFSET ?
    """
    return conn.execute(sql, (limit, offset)).fetchall()

def _fetch_dest_count(conn: sqlite3.Connection) -> int:
    sql = "SELECT COUNT(DISTINCT dest_city || '|' || dest_country) AS c FROM flights"
    return conn.execute(sql).fetchone()["c"]

def _fetch_prices_for_dest(conn: sqlite3.Connection, city: str, country: str, seats_min: int,
                           vis_filter: str, now: dt.datetime) -> List[sqlite3.Row]:
    """
    ××—×–×™×¨ ×¢×“ 10 ××—×™×¨×™× ×œ×™×¢×“, ×‘×”×ª×× ×œ×¤×™×œ×˜×¨ × ×¨××•×ª (×—×“×©×•×ª/×§×™×™××•×ª/×™×¨×“×•).
    * ×”×¢×¨×”: '×™×¨×“×•' ×ª×œ×•×™ ×‘××™××•×© ×”×¡×§×¨×™×™×¤×¨/×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡. ×›××Ÿ × ×’×“×™×¨:
      - 'new'   : last_seen >= now - 60 ×“×§×•×ª
      - 'active': last_seen ×œ× ×™×©×Ÿ ×-24 ×©×¢×•×ª (× ×™×ª×Ÿ ×œ×›×•×•×Ÿ), ×‘×ª×•×¨ ×§×™×¨×•×‘ "×§×™×™×"
      - 'gone'  : ×œ× ××•×¦×’ ×›××Ÿ â€“ ×“×•×¨×© ×˜×‘×œ×ª ××¨×›×™×•×Ÿ/×¡×˜×˜×•×¡; × ×¦×™×’ ×¨×©×™××” ×¨×™×§×” ×•× ×¡××Ÿ ×‘×˜×§×¡×˜.
    """
    args: List[object] = [city, country]
    where = "dest_city=? AND dest_country=?"

    if vis_filter == "new":
        where += " AND last_seen >= ?"
        args.append((now - dt.timedelta(minutes=NEW_WINDOW_MINUTES)).isoformat(" "))
    elif vis_filter == "active":
        where += " AND last_seen >= ?"
        # ×§×™×¨×•×‘ "×§×™×™×": × ×¨××” ×‘-24 ×©×¢×•×ª ×”××—×¨×•× ×•×ª
        args.append((now - dt.timedelta(hours=24)).isoformat(" "))

    # ××•×©×‘×™× ××™× ×™××œ×™×™×: ××™×Ÿ ×œ× ×• ×¢××•×“×ª ×›××•×ª ×‘×¤×•×¢×œ; × × ×¡×” ×œ×××•×“ ××ª×•×š badge_text.
    # ×× ××™×Ÿ ××™×“×¢ â€“ × ×ª×™×™×—×¡ ×›××™×œ×• ×¢×•××“ ×‘×“×¨×™×©×” (×›×¤×™ ×©×¡×™×›×× ×•).
    seats_clause = """
      AND (
        badge_text IS NULL
        OR badge_text=''
        OR CAST(REPLACE(REPLACE(badge_text, ' ××§×•××•×ª ××—×¨×•× ×™×', ''), ' ××§×•××•×ª', '') AS INTEGER) >= ?
        OR badge_text NOT LIKE '%××§×•××•×ª%'
      )
    """
    where += seats_clause
    args.append(seats_min)

    sql = f"""
    SELECT
      trip_title,
      price, currency, price_text,
      last_seen, badge_text
    FROM flights
    WHERE {where}
    ORDER BY price ASC NULLS LAST, last_seen DESC
    LIMIT 10
    """
    return conn.execute(sql, args).fetchall()

def _summary_counts_by_dest(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    sql = """
    SELECT
      COALESCE(dest_city,'') AS city,
      COALESCE(dest_country,'') AS country,
      COUNT(*) AS offers
    FROM flights
    GROUP BY dest_city, dest_country
    ORDER BY offers DESC, country, city
    """
    return conn.execute(sql).fetchall()

# ========== ××¦×‘ ××©×ª××© ==========
def _ensure_user_state(context: ContextTypes.DEFAULT_TYPE) -> Dict[str, object]:
    s = context.user_data.setdefault("main_state", {})
    # ×‘×¨×™×¨×•×ª ××—×“×œ â€“ ×›×¤×™ ×©×‘×™×§×©×ª
    s.setdefault("dst_all", True)          # "×›×œ ×”×™×¢×“×™×" ×“×™×¤×•×œ×˜
    s.setdefault("dst_city", "")
    s.setdefault("dst_country", "")
    s.setdefault("dst_offset", 0)          # ×œ×¤×’'×™× ×¦×™×™×ª ×™×¢×“×™×
    s.setdefault("date_mode", "none")      # "none" / "exact" / "plusminus"
    s.setdefault("date_exact", None)       # "YYYY-MM-DD" ×× × ×‘×—×¨
    s.setdefault("seats_min", 1)           # 1..5
    s.setdefault("visibility", "active")   # "new" / "active" / "gone"
    return s  # type: ignore[return-value]

# ========== ×‘× ×™×™×ª ××¡×š ×¨××©×™ ==========
def _build_dest_buttons(conn: sqlite3.Connection, s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    offset = int(s.get("dst_offset", 0))
    rows = _fetch_destinations(conn, offset=offset, limit=MAX_DESTS_PER_PAGE)

    buttons: List[InlineKeyboardButton] = []
    # "×›×œ ×”×™×¢×“×™×"
    all_selected = bool(s.get("dst_all", False))
    prefix = "âœ… " if all_selected else ""
    buttons.append(InlineKeyboardButton(f"{prefix}×›×œ ×”×™×¢×“×™× ğŸŒ", callback_data="dst_all"))

    # ×™×¢×“×™× ×‘×•×“×“×™×
    sel_city = str(s.get("dst_city") or "")
    sel_country = str(s.get("dst_country") or "")
    for r in rows:
        city = r["city"] or "â€”"
        country = r["country"] or ""
        price_disp = format_price(r["currency"], r["min_price"])
        is_sel = (not all_selected) and (city == sel_city and country == sel_country)
        label = f"{'âœ… ' if is_sel else ''}{city}"
        if country:
            label = f"{label} Â· {price_disp or ''}"
        buttons.append(InlineKeyboardButton(label[:60], callback_data=f"dst:{city}|{country}"))

    # ×¤×¨×™×¡×ª 2 ×˜×•×¨×™×
    grid: List[List[InlineKeyboardButton]] = []
    row: List[InlineKeyboardButton] = []
    for b in buttons:
        row.append(b)
        if len(row) == DEST_COLS:
            grid.append(row); row = []
    if row:
        grid.append(row)

    # ×©×•×¨×ª × ×™×•×•×˜ ×™×¢×“×™×
    total = _fetch_dest_count(conn)
    next_off = offset + MAX_DESTS_PER_PAGE
    prev_off = max(0, offset - MAX_DESTS_PER_PAGE)
    nav_row: List[InlineKeyboardButton] = []
    nav_row.append(InlineKeyboardButton("â¬…ï¸ ×¢×•×“ ×™×¢×“×™×", callback_data=f"dst_more:{next_off}") if next_off < total
                   else InlineKeyboardButton("â€”", callback_data="noop"))
    nav_row.append(InlineKeyboardButton("â†©ï¸ ×”×§×•×“×", callback_data=f"dst_page:{prev_off}") if offset > 0
                   else InlineKeyboardButton("â€”", callback_data="noop"))
    grid.append(nav_row)

    return grid

def _build_date_block(s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    """
    ×‘×œ×•×§ ×ª××¨×™×›×™× "×¤×ª×•×—" â€“ ××¦×™×’ ××™×“ ×¨×©×ª ×©×œ ×ª××¨×™×›×™× (×”×™×•× + 6 ×™××™×),
    ×™×—×“ ×¢× ××¦×‘ Â±3 ×™××™× ×•/××• '×œ×œ×'.
    """
    today = dt.date.today()
    exact = s.get("date_exact")
    mode = s.get("date_mode", "none")

    # ×©×•×¨×ª ×›×•×ª×¨×ª ×œ××¦×‘
    title = "ğŸ—“ ×ª××¨×™×š ××“×•×™×§" if mode == "exact" else ("Â±3 ×™××™×" if mode == "plusminus" else "×œ×œ× ×ª××¨×™×š")
    hdr = [InlineKeyboardButton(f"{'âœ… ' if mode!='none' else ''}{title}", callback_data="noop")]

    # ×¨×©×ª ×ª××¨×™×›×™× â€“ 7 ×™××™× ×§×“×™××”
    day_rows: List[List[InlineKeyboardButton]] = []
    current_row: List[InlineKeyboardButton] = []
    for i in range(7):
        d = today + dt.timedelta(days=i)
        selected = (str(exact) == d.isoformat())
        label = f"{'âœ… ' if selected else ''}{d.strftime('%d/%m')}"
        current_row.append(InlineKeyboardButton(label, callback_data=f"date:{d.isoformat()}"))
        if len(current_row) == 7:
            day_rows.append(current_row); current_row = []
    if current_row:
        day_rows.append(current_row)

    # ×©×•×¨×ª ××¤×©×¨×•×™×•×ª ××¦×‘
    opts = [
        InlineKeyboardButton(("âœ… " if mode == "exact" else "") + "××“×•×™×§", callback_data="date_mode:exact"),
        InlineKeyboardButton(("âœ… " if mode == "plusminus" else "") + "Â±3 ×™××™×", callback_data="date_mode:plusminus"),
        InlineKeyboardButton(("âœ… " if mode == "none" else "") + "×œ×œ×", callback_data="date_mode:none"),
    ]

    return [hdr] + day_rows + [opts]

def _build_seats_block(s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    seats = int(s.get("seats_min", 1))
    row: List[InlineKeyboardButton] = []
    for n in (1, 2, 3, 4, 5):
        row.append(InlineKeyboardButton(f"{'âœ… ' if seats==n else ''}{n}", callback_data=f"seats:{n}"))
    return [ [ InlineKeyboardButton("ğŸ‘¥ ××™× ' ××•×©×‘×™×", callback_data="noop") ],
             row ]

def _build_visibility_block(s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    vis = str(s.get("visibility", "active"))
    row = [
        InlineKeyboardButton(("âœ… " if vis == "new" else "") + "×—×“×©×•×ª â±", callback_data="vis:new"),
        InlineKeyboardButton(("âœ… " if vis == "active" else "") + "×§×™×™××•×ª ğŸŸ¢", callback_data="vis:active"),
        InlineKeyboardButton(("âœ… " if vis == "gone" else "") + "×™×¨×“×• â›”ï¸", callback_data="vis:gone"),
    ]
    return [ [ InlineKeyboardButton("ğŸ‘ × ×¨××•×ª", callback_data="noop") ],
             row ]

def _build_main_keyboard(conn: sqlite3.Connection, s: Dict[str, object]) -> InlineKeyboardMarkup:
    kb: List[List[InlineKeyboardButton]] = []
    # ×™×¢×“×™×
    kb += _build_dest_buttons(conn, s)
    # ×ª××¨×™×›×™×
    kb += _build_date_block(s)
    # ××•×©×‘×™×
    kb += _build_seats_block(s)
    # × ×¨××•×ª
    kb += _build_visibility_block(s)
    # ×©×•×¨×ª ×¤×¢×•×œ×•×ª ×ª×—×ª×•× ×”
    kb.append([
        InlineKeyboardButton("ğŸ”„ ×¨×¢× ×•×Ÿ", callback_data="refresh"),
        InlineKeyboardButton("ğŸ“Š ×¡×™×›×•× ×™×¢×“×™×", callback_data="summary"),
    ])
    return InlineKeyboardMarkup(kb)

def _compose_text(conn: sqlite3.Connection, s: Dict[str, object]) -> str:
    now = dt.datetime.now()
    greet = format_greeting(now)

    # ×›×•×ª×¨×ª ×¡×™×›×•× ×§×¦×¨×”: ××¡×¤×¨ ××‘×¦×¢×™×
    total = conn.execute("SELECT COUNT(*) AS c FROM flights").fetchone()["c"]
    header = f"{greet}\n×™×© ×›×¨×’×¢ {total} ××‘×¦×¢×™× ×¤×¢×™×œ×™× (×§×™×¨×•×‘)."

    # ×× × ×‘×—×¨ ×™×¢×“ ×‘×•×“×“ â€“ × ×¦×¨×£ ×¨×©×™××ª ××—×™×¨×™×
    extra = ""
    if not s.get("dst_all", True):
        city = str(s.get("dst_city") or "")
        country = str(s.get("dst_country") or "")
        rows = _fetch_prices_for_dest(
            conn, city, country,
            seats_min=int(s.get("seats_min", 1)),
            vis_filter=str(s.get("visibility", "active")),
            now=now
        )
        if rows:
            lines = [f"\n×™×¢×“×™× ×¢×‘×•×¨ {city}:"]
            for r in rows:
                price_disp = format_price(r["currency"], r["price"], fallback=r["price_text"])
                lines.append(f"âœ… {price_disp}")
            extra = "\n".join(lines)
        else:
            vis = s.get("visibility", "active")
            extra = f"\n(××™×Ÿ ×ª×•×¦××•×ª ×œ{city} ×‘××¦×‘ '{vis}')"

    sel_line = "\n" + summarize_selection(s)
    return header + sel_line + extra

def _build_main_screen(conn: sqlite3.Connection, s: Dict[str, object]) -> Tuple[str, InlineKeyboardMarkup]:
    text = _compose_text(conn, s)
    km = _build_main_keyboard(conn, s)
    return text, km

# ========== Handlers ==========
async def handle_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    s = _ensure_user_state(context)
    conn = db.get_conn()  # ×¤×•× ×§×¦×™×” ×§×™×™××ª ××¦×œ×š â€“ ×‘×œ×™ path
    text, km = _build_main_screen(conn, s)
    await update.effective_message.reply_text(text, reply_markup=km)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query
    await q.answer()
    data = (q.data or "").strip()
    s = _ensure_user_state(context)
    changed = False

    # --- ×™×¢×“×™× ---
    if data == "dst_all":
        s["dst_all"] = True
        s["dst_city"] = ""
        s["dst_country"] = ""
        changed = True
    elif data.startswith("dst:"):
        try:
            city, country = data[4:].split("|", 1)
        except ValueError:
            city, country = data[4:], ""
        s["dst_all"] = False
        s["dst_city"] = city
        s["dst_country"] = country
        changed = True
    elif data.startswith("dst_more:"):
        s["dst_offset"] = int(data.split(":", 1)[1])
        changed = True
    elif data.startswith("dst_page:"):
        s["dst_offset"] = int(data.split(":", 1)[1])
        changed = True

    # --- ×ª××¨×™×›×™× ---
    elif data.startswith("date_mode:"):
        s["date_mode"] = data.split(":", 1)[1]  # exact / plusminus / none
        changed = True
    elif data.startswith("date:"):
        s["date_exact"] = data.split(":", 1)[1]  # YYYY-MM-DD
        s["date_mode"] = "exact"
        changed = True

    # --- ××•×©×‘×™× ××™× ×™××œ×™×™× ---
    elif data.startswith("seats:"):
        s["seats_min"] = int(data.split(":", 1)[1])
        changed = True

    # --- × ×¨××•×ª ---
    elif data.startswith("vis:"):
        s["visibility"] = data.split(":", 1)[1]   # new / active / gone
        changed = True

    # --- ×¡×™×›×•× ×™×¢×“×™× ---
    elif data == "summary":
        conn = db.get_conn()
        rows = _summary_counts_by_dest(conn)
        if rows:
            lines = ["ğŸ“Š ×¡×™×›×•× ×œ×¤×™ ×™×¢×“:"]
            for r in rows[:30]:  # ×œ× ×œ×”×¢××™×¡
                lines.append(f"â€¢ {r['city']} ({r['country']}) â€” {r['offers']}")
            text = "\n".join(lines)
        else:
            text = "××™×Ÿ × ×ª×•× ×™× ×œ×¡×™×›×•× ×›×¨×’×¢."

        # ×ª×¤×¨×™×˜ ×¨××©×™ × ×©××¨ ×–×”×”; × ×•×•×“× ×©×™× ×•×™ ×˜×§×¡×˜ ×œ×× ×™×¢×ª BadRequest
        km = _build_main_keyboard(conn, s)
        old_text = q.message.text or ""
        if old_text == text:
            text += INVISIBLE
        await q.edit_message_text(text, reply_markup=km)
        return

    # --- ×¨×¢× ×•×Ÿ ××• noop ---
    elif data in ("refresh", "noop"):
        changed = True  # × ×›×¨×™×— ×¨× ×“×¨

    # ×¨× ×“×¨
    if changed:
        conn = db.get_conn()
        text, km = _build_main_screen(conn, s)
        # ×× ×™×¢×ª "Message is not modified"
        old_text = q.message.text or ""
        old_km = q.message.reply_markup
        if old_text == text and str(old_km) == str(km):
            text += INVISIBLE
        await q.edit_message_text(text, reply_markup=km)
