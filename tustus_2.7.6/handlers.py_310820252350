from __future__ import annotations

import asyncio
import datetime as dt
import sqlite3
from typing import Dict, List, Tuple, Optional

from telegram import (
    Update,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from telegram.ext import ContextTypes

import db  # לא נוגע בקובץ הזה – רק משתמש ב- db.get_conn()

# ========= תצוגה =========
from telegram_view import (
    format_greeting,
    summarize_selection,
    format_price,
)

INVISIBLE = "\u2063"  # למניעת "Message is not modified"
MAX_DESTS_PER_PAGE = 12   # כמות כפתורי יעדים בו-זמנית
DEST_COLS = 2             # שני טורים לכפתורי היעדים
NEW_WINDOW_MINUTES = 60   # "חדשות" = נכנסו בשעה האחרונה

# ========== עוזרים ל-DB ==========
def _fetch_destinations(conn: sqlite3.Connection, offset: int = 0, limit: int = MAX_DESTS_PER_PAGE
                        ) -> List[sqlite3.Row]:
    """
    מביא רשימת יעדים (עיר+מדינה) עם מחיר מינימלי להצגה בכפתור.
    עובד על הסכימה העשירה: dest_city, dest_country, price, currency.
    """
    sql = """
    SELECT
        COALESCE(dest_city,'')   AS city,
        COALESCE(dest_country,'') AS country,
        MIN(price)               AS min_price,
        MAX(currency)            AS currency
    FROM flights
    GROUP BY dest_city, dest_country
    ORDER BY country, city
    LIMIT ? OFFSET ?
    """
    return conn.execute(sql, (limit, offset)).fetchall()

def _fetch_dest_count(conn: sqlite3.Connection) -> int:
    sql = "SELECT COUNT(DISTINCT dest_city || '|' || dest_country) AS c FROM flights"
    return conn.execute(sql).fetchone()["c"]

def _fetch_prices_for_dest(conn: sqlite3.Connection, city: str, country: str, seats_min: int,
                           vis_filter: str, now: dt.datetime) -> List[sqlite3.Row]:
    """
    מחזיר עד 10 מחירים ליעד, בהתאם לפילטר נראות (חדשות/קיימות/ירדו).
    * הערה: 'ירדו' תלוי במימוש הסקרייפר/עדכון סטטוס. כאן נגדיר:
      - 'new'   : last_seen >= now - 60 דקות
      - 'active': last_seen לא ישן מ-24 שעות (ניתן לכוון), בתור קירוב "קיים"
      - 'gone'  : לא מוצג כאן – דורש טבלת ארכיון/סטטוס; נציג רשימה ריקה ונסמן בטקסט.
    """
    args: List[object] = [city, country]
    where = "dest_city=? AND dest_country=?"

    if vis_filter == "new":
        where += " AND last_seen >= ?"
        args.append((now - dt.timedelta(minutes=NEW_WINDOW_MINUTES)).isoformat(" "))
    elif vis_filter == "active":
        where += " AND last_seen >= ?"
        # קירוב "קיים": נראה ב-24 שעות האחרונות
        args.append((now - dt.timedelta(hours=24)).isoformat(" "))

    # מושבים מינימליים: אין לנו עמודת כמות בפועל; ננסה לאמוד מתוך badge_text.
    # אם אין מידע – נתייחס כאילו עומד בדרישה (כפי שסיכמנו).
    seats_clause = """
      AND (
        badge_text IS NULL
        OR badge_text=''
        OR CAST(REPLACE(REPLACE(badge_text, ' מקומות אחרונים', ''), ' מקומות', '') AS INTEGER) >= ?
        OR badge_text NOT LIKE '%מקומות%'
      )
    """
    where += seats_clause
    args.append(seats_min)

    sql = f"""
    SELECT
      trip_title,
      price, currency, price_text,
      last_seen, badge_text
    FROM flights
    WHERE {where}
    ORDER BY price ASC NULLS LAST, last_seen DESC
    LIMIT 10
    """
    return conn.execute(sql, args).fetchall()

def _summary_counts_by_dest(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    sql = """
    SELECT
      COALESCE(dest_city,'') AS city,
      COALESCE(dest_country,'') AS country,
      COUNT(*) AS offers
    FROM flights
    GROUP BY dest_city, dest_country
    ORDER BY offers DESC, country, city
    """
    return conn.execute(sql).fetchall()

# ========== מצב משתמש ==========
def _ensure_user_state(context: ContextTypes.DEFAULT_TYPE) -> Dict[str, object]:
    s = context.user_data.setdefault("main_state", {})
    # ברירות מחדל – כפי שביקשת
    s.setdefault("dst_all", True)          # "כל היעדים" דיפולט
    s.setdefault("dst_city", "")
    s.setdefault("dst_country", "")
    s.setdefault("dst_offset", 0)          # לפג'ינציית יעדים
    s.setdefault("date_mode", "none")      # "none" / "exact" / "plusminus"
    s.setdefault("date_exact", None)       # "YYYY-MM-DD" אם נבחר
    s.setdefault("seats_min", 1)           # 1..5
    s.setdefault("visibility", "active")   # "new" / "active" / "gone"
    return s  # type: ignore[return-value]

# ========== בניית מסך ראשי ==========
def _build_dest_buttons(conn: sqlite3.Connection, s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    offset = int(s.get("dst_offset", 0))
    rows = _fetch_destinations(conn, offset=offset, limit=MAX_DESTS_PER_PAGE)

    buttons: List[InlineKeyboardButton] = []
    # "כל היעדים"
    all_selected = bool(s.get("dst_all", False))
    prefix = "✅ " if all_selected else ""
    buttons.append(InlineKeyboardButton(f"{prefix}כל היעדים 🌐", callback_data="dst_all"))

    # יעדים בודדים
    sel_city = str(s.get("dst_city") or "")
    sel_country = str(s.get("dst_country") or "")
    for r in rows:
        city = r["city"] or "—"
        country = r["country"] or ""
        price_disp = format_price(r["currency"], r["min_price"])
        is_sel = (not all_selected) and (city == sel_city and country == sel_country)
        label = f"{'✅ ' if is_sel else ''}{city}"
        if country:
            label = f"{label} · {price_disp or ''}"
        buttons.append(InlineKeyboardButton(label[:60], callback_data=f"dst:{city}|{country}"))

    # פריסת 2 טורים
    grid: List[List[InlineKeyboardButton]] = []
    row: List[InlineKeyboardButton] = []
    for b in buttons:
        row.append(b)
        if len(row) == DEST_COLS:
            grid.append(row); row = []
    if row:
        grid.append(row)

    # שורת ניווט יעדים
    total = _fetch_dest_count(conn)
    next_off = offset + MAX_DESTS_PER_PAGE
    prev_off = max(0, offset - MAX_DESTS_PER_PAGE)
    nav_row: List[InlineKeyboardButton] = []
    nav_row.append(InlineKeyboardButton("⬅️ עוד יעדים", callback_data=f"dst_more:{next_off}") if next_off < total
                   else InlineKeyboardButton("—", callback_data="noop"))
    nav_row.append(InlineKeyboardButton("↩️ הקודם", callback_data=f"dst_page:{prev_off}") if offset > 0
                   else InlineKeyboardButton("—", callback_data="noop"))
    grid.append(nav_row)

    return grid

def _build_date_block(s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    """
    בלוק תאריכים "פתוח" – מציג מיד רשת של תאריכים (היום + 6 ימים),
    יחד עם מצב ±3 ימים ו/או 'ללא'.
    """
    today = dt.date.today()
    exact = s.get("date_exact")
    mode = s.get("date_mode", "none")

    # שורת כותרת למצב
    title = "🗓 תאריך מדויק" if mode == "exact" else ("±3 ימים" if mode == "plusminus" else "ללא תאריך")
    hdr = [InlineKeyboardButton(f"{'✅ ' if mode!='none' else ''}{title}", callback_data="noop")]

    # רשת תאריכים – 7 ימים קדימה
    day_rows: List[List[InlineKeyboardButton]] = []
    current_row: List[InlineKeyboardButton] = []
    for i in range(7):
        d = today + dt.timedelta(days=i)
        selected = (str(exact) == d.isoformat())
        label = f"{'✅ ' if selected else ''}{d.strftime('%d/%m')}"
        current_row.append(InlineKeyboardButton(label, callback_data=f"date:{d.isoformat()}"))
        if len(current_row) == 7:
            day_rows.append(current_row); current_row = []
    if current_row:
        day_rows.append(current_row)

    # שורת אפשרויות מצב
    opts = [
        InlineKeyboardButton(("✅ " if mode == "exact" else "") + "מדויק", callback_data="date_mode:exact"),
        InlineKeyboardButton(("✅ " if mode == "plusminus" else "") + "±3 ימים", callback_data="date_mode:plusminus"),
        InlineKeyboardButton(("✅ " if mode == "none" else "") + "ללא", callback_data="date_mode:none"),
    ]

    return [hdr] + day_rows + [opts]

def _build_seats_block(s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    seats = int(s.get("seats_min", 1))
    row: List[InlineKeyboardButton] = []
    for n in (1, 2, 3, 4, 5):
        row.append(InlineKeyboardButton(f"{'✅ ' if seats==n else ''}{n}", callback_data=f"seats:{n}"))
    return [ [ InlineKeyboardButton("👥 מינ' מושבים", callback_data="noop") ],
             row ]

def _build_visibility_block(s: Dict[str, object]) -> List[List[InlineKeyboardButton]]:
    vis = str(s.get("visibility", "active"))
    row = [
        InlineKeyboardButton(("✅ " if vis == "new" else "") + "חדשות ⏱", callback_data="vis:new"),
        InlineKeyboardButton(("✅ " if vis == "active" else "") + "קיימות 🟢", callback_data="vis:active"),
        InlineKeyboardButton(("✅ " if vis == "gone" else "") + "ירדו ⛔️", callback_data="vis:gone"),
    ]
    return [ [ InlineKeyboardButton("👁 נראות", callback_data="noop") ],
             row ]

def _build_main_keyboard(conn: sqlite3.Connection, s: Dict[str, object]) -> InlineKeyboardMarkup:
    kb: List[List[InlineKeyboardButton]] = []
    # יעדים
    kb += _build_dest_buttons(conn, s)
    # תאריכים
    kb += _build_date_block(s)
    # מושבים
    kb += _build_seats_block(s)
    # נראות
    kb += _build_visibility_block(s)
    # שורת פעולות תחתונה
    kb.append([
        InlineKeyboardButton("🔄 רענון", callback_data="refresh"),
        InlineKeyboardButton("📊 סיכום יעדים", callback_data="summary"),
    ])
    return InlineKeyboardMarkup(kb)

def _compose_text(conn: sqlite3.Connection, s: Dict[str, object]) -> str:
    now = dt.datetime.now()
    greet = format_greeting(now)

    # כותרת סיכום קצרה: מספר מבצעים
    total = conn.execute("SELECT COUNT(*) AS c FROM flights").fetchone()["c"]
    header = f"{greet}\nיש כרגע {total} מבצעים פעילים (קירוב)."

    # אם נבחר יעד בודד – נצרף רשימת מחירים
    extra = ""
    if not s.get("dst_all", True):
        city = str(s.get("dst_city") or "")
        country = str(s.get("dst_country") or "")
        rows = _fetch_prices_for_dest(
            conn, city, country,
            seats_min=int(s.get("seats_min", 1)),
            vis_filter=str(s.get("visibility", "active")),
            now=now
        )
        if rows:
            lines = [f"\nיעדים עבור {city}:"]
            for r in rows:
                price_disp = format_price(r["currency"], r["price"], fallback=r["price_text"])
                lines.append(f"✅ {price_disp}")
            extra = "\n".join(lines)
        else:
            vis = s.get("visibility", "active")
            extra = f"\n(אין תוצאות ל{city} במצב '{vis}')"

    sel_line = "\n" + summarize_selection(s)
    return header + sel_line + extra

def _build_main_screen(conn: sqlite3.Connection, s: Dict[str, object]) -> Tuple[str, InlineKeyboardMarkup]:
    text = _compose_text(conn, s)
    km = _build_main_keyboard(conn, s)
    return text, km

# ========== Handlers ==========
async def handle_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    s = _ensure_user_state(context)
    conn = db.get_conn()  # פונקציה קיימת אצלך – בלי path
    text, km = _build_main_screen(conn, s)
    await update.effective_message.reply_text(text, reply_markup=km)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query
    await q.answer()
    data = (q.data or "").strip()
    s = _ensure_user_state(context)
    changed = False

    # --- יעדים ---
    if data == "dst_all":
        s["dst_all"] = True
        s["dst_city"] = ""
        s["dst_country"] = ""
        changed = True
    elif data.startswith("dst:"):
        try:
            city, country = data[4:].split("|", 1)
        except ValueError:
            city, country = data[4:], ""
        s["dst_all"] = False
        s["dst_city"] = city
        s["dst_country"] = country
        changed = True
    elif data.startswith("dst_more:"):
        s["dst_offset"] = int(data.split(":", 1)[1])
        changed = True
    elif data.startswith("dst_page:"):
        s["dst_offset"] = int(data.split(":", 1)[1])
        changed = True

    # --- תאריכים ---
    elif data.startswith("date_mode:"):
        s["date_mode"] = data.split(":", 1)[1]  # exact / plusminus / none
        changed = True
    elif data.startswith("date:"):
        s["date_exact"] = data.split(":", 1)[1]  # YYYY-MM-DD
        s["date_mode"] = "exact"
        changed = True

    # --- מושבים מינימליים ---
    elif data.startswith("seats:"):
        s["seats_min"] = int(data.split(":", 1)[1])
        changed = True

    # --- נראות ---
    elif data.startswith("vis:"):
        s["visibility"] = data.split(":", 1)[1]   # new / active / gone
        changed = True

    # --- סיכום יעדים ---
    elif data == "summary":
        conn = db.get_conn()
        rows = _summary_counts_by_dest(conn)
        if rows:
            lines = ["📊 סיכום לפי יעד:"]
            for r in rows[:30]:  # לא להעמיס
                lines.append(f"• {r['city']} ({r['country']}) — {r['offers']}")
            text = "\n".join(lines)
        else:
            text = "אין נתונים לסיכום כרגע."

        # תפריט ראשי נשאר זהה; נוודא שינוי טקסט למניעת BadRequest
        km = _build_main_keyboard(conn, s)
        old_text = q.message.text or ""
        if old_text == text:
            text += INVISIBLE
        await q.edit_message_text(text, reply_markup=km)
        return

    # --- רענון או noop ---
    elif data in ("refresh", "noop"):
        changed = True  # נכריח רנדר

    # רנדר
    if changed:
        conn = db.get_conn()
        text, km = _build_main_screen(conn, s)
        # מניעת "Message is not modified"
        old_text = q.message.text or ""
        old_km = q.message.reply_markup
        if old_text == text and str(old_km) == str(km):
            text += INVISIBLE
        await q.edit_message_text(text, reply_markup=km)
