from __future__ import annotations
from typing import Dict, Any, Tuple, List, Optional
import datetime as dt
import sqlite3

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes

import db  # ×œ× × ×•×’×¢×™× ×‘××•×“×•×œ, ×¨×§ ××©×ª××©×™× ×‘×• ×›××• ×©×”×•×


# =========================
# ××¦×‘ ×‘×—×™×¨×” ×‘×–×™×›×¨×•×Ÿ ×œ×›×œ ××©×ª××©/×¦'××˜ (×œ×œ× ×”×ª××“×” ×‘×“×™×¡×§)
# =========================
# session state structure:
# {
#   "destinations": set[str] | {"__ALL__"},
#   "date": Optional[str: YYYY-MM-DD],
#   "flex3": bool,   # +/- 3 ×™××™×
#   "seats_min": int,  # 1..5 (×× ×œ× ×™×“×•×¢ ×‘×˜×™×¡×” â€” × ×—×©×‘ 5)
#   "visibility": "new" | "live" | "old" | "any"
# }
SESS: Dict[int, Dict[str, Any]] = {}


# =========================
# ×›×œ×™ DB
# =========================
def _conn() -> sqlite3.Connection:
    """
    × ×¡×™×•×Ÿ ×¨××©×•×Ÿ: db.get_conn() ×›××• ××¦×œ×š; ×× ×“×•×¨×© path, × ×©×ª××© ×‘××” ×©Ö¾db ××’×“×™×¨ ×›×‘×¨×™×¨×ª ××—×“×œ.
    ×œ× ××©× ×™× ××ª db.py.
    """
    try:
        return db.get_conn()  # ×¡×•×’×¨×™×™× ×›×‘×§×©×ª×š ×‘×’×¨×¡××•×ª ×”××—×¨×•× ×•×ª
    except TypeError:
        # ×”×ª×××ª ××—×•×¨×” â€” ×× ×¤×•× ×§×¦×™×” ×“×•×¨×©×ª path:
        try:
            from config import DB_PATH  # ×œ× ××©× ×” ××ª config, ×¨×§ ×§×•×¨×
            return db.get_conn(DB_PATH)
        except Exception:
            # ×‘×¨×™×¨×ª ××—×“×œ ×œÖ¾./flights.db ×× ××™×Ÿ ×›×œ×•×
            return db.get_conn("./flights.db")


def _row_dicts(rows) -> List[Dict[str, Any]]:
    return [dict(r) if not isinstance(r, dict) else r for r in rows]


# =========================
# ×”×’×“×¨×•×ª ×‘×¨×™×¨×ª ××—×“×œ ×œ××¦×‘
# =========================
def _ensure_session(chat_id: int) -> Dict[str, Any]:
    s = SESS.get(chat_id)
    if not s:
        s = {
            "destinations": set(),   # ××¤×©×¨ ×’× "__ALL__"
            "date": None,            # "YYYY-MM-DD"
            "flex3": False,          # +/- 3 ×™××™×
            "seats_min": 1,          # 1..5
            "visibility": "any",     # "new"/"live"/"old"/"any"
        }
        SESS[chat_id] = s
    return s


# =========================
# ×©××™×œ×ª×•×ª ×¢×–×¨
# =========================
def _distinct_destinations(conn: sqlite3.Connection) -> List[str]:
    # × × ×¡×” ×§×•×“× ×¢×™×¨, ×× ×œ×â€”destination
    # ×§×™×™××•×ª ×’×¨×¡××•×ª ×©×•× ×•×ª ×©×œ ×”×¡×›×™××”, ×œ×›×Ÿ ××©×ª××©×™× ×‘-COALESCE.
    q = """
        SELECT DISTINCT TRIM(COALESCE(dest_city, destination, '')) AS d
        FROM flights
        WHERE TRIM(COALESCE(dest_city, destination, '')) <> ''
        ORDER BY d COLLATE NOCASE
    """
    try:
        conn.row_factory = sqlite3.Row
        return [r["d"] for r in conn.execute(q).fetchall()]
    except Exception:
        # ×”×ª×××” ×œ×¡×›×™××•×ª ×™×©× ×•×ª ×××•×“
        q2 = """
            SELECT DISTINCT TRIM(COALESCE(destination, '')) AS d
            FROM flights
            WHERE TRIM(COALESCE(destination, '')) <> ''
            ORDER BY d COLLATE NOCASE
        """
        return [r[0] for r in conn.execute(q2).fetchall()]


def _summary_by_destination(conn: sqlite3.Connection, s: Dict[str, Any]) -> List[Tuple[str, int]]:
    """
    ××—×–×™×¨ [(×™×¢×“, ×›××•×ª)] ×œ×¤×™ ×”×¡×™× ×•×Ÿ ×©× ×‘×—×¨â€”×‘×¦×•×¨×” ×’××™×©×” ×œ×¡×›×™××•×ª ×©×•× ×•×ª.
    """
    conn.row_factory = sqlite3.Row
    where = []
    args: List[Any] = []

    # ×™×¢×“
    if s["destinations"] and "__ALL__" not in s["destinations"]:
        placeholders = ",".join("?" for _ in s["destinations"])
        where.append(f"TRIM(COALESCE(dest_city, destination, '')) IN ({placeholders})")
        args.extend(sorted(list(s["destinations"])))

    # ×ª××¨×™×š (×œ×¤×™ ×˜×§×¡×˜×™× ×× ×§×™×™××™× ×‘×©×“×•×ª ×”×—×“×©×™×) â€” ×× ××™×Ÿ ×©×“×•×ª, ××ª×¢×œ××™× ×‘×©×§×˜
    date_sql = None
    flex = s.get("flex3", False)
    if s.get("date"):
        try:
            d0 = dt.date.fromisoformat(s["date"])
            if flex:
                d1 = d0 - dt.timedelta(days=3)
                d2 = d0 + dt.timedelta(days=3)
            else:
                d1 = d0
                d2 = d0
            # × × ×¡×” ×œ×”×ª××™× ×œ×©×“×•×ª ×˜×§×¡×˜×•××œ×™×™× ××”Ö¾HTML contract, ×× ×§×™×™××™×:
            # out_date/back_date ×‘×¤×•×¨××˜ YYYY-MM-DD (×× × ×©××¨×• ×¢"×™ ×”×¡×§×¨×™×™×¤×¨ ×”×—×“×©)
            date_sql = "( (out_date BETWEEN ? AND ?) OR (back_date BETWEEN ? AND ?) )"
            args.extend([d1.isoformat(), d2.isoformat(), d1.isoformat(), d2.isoformat()])
            where.append(date_sql)
        except Exception:
            pass

    # ××•×©×‘×™× ××™× ×™××œ×™ â€” ×× ××™×Ÿ ×¢××•×“×” seats, ×× ×™×—×™× 5 ×‘×˜×™×¡×•×ª ×—×¡×¨×•×ª, ×•×”×¡× ×Ÿ ×œ× ×™×¤×™×œ ××•×ª×Ÿ
    seats_sql = "(COALESCE(seats, 5) >= ?)"
    args.append(int(s.get("seats_min", 1)))
    where.append(seats_sql)

    # × ×¨××•×ª: new/live/old/any â€” ×œ×¤×™ last_seen ×–××™×Ÿ ×‘×›×œ ×”×’×¨×¡××•×ª ×”××—×¨×•× ×•×ª
    vis = s.get("visibility", "any")
    now = dt.datetime.utcnow()
    one_hour = now - dt.timedelta(hours=1)
    two_hours = now - dt.timedelta(hours=2)

    if vis == "new":
        where.append("(COALESCE(last_seen, CURRENT_TIMESTAMP) >= ?)")
        args.append(one_hour.isoformat(sep=" "))
    elif vis == "live":
        # â€œ×§×™×™××•×ªâ€ â€” ×¨××™× ×• ×‘××”×œ×š ×”×©×¢×ª×™×™× ×”××—×¨×•× ×•×ª (×’××™×©)
        where.append("(COALESCE(last_seen, '') >= ?)")
        args.append(two_hours.isoformat(sep=" "))
    elif vis == "old":
        # â€œ×™×©× ×•×ª/×™×¨×“×•â€ â€” ×œ× × ×¨××• ×œ×¤×—×•×ª ×©×¢×ª×™×™×
        where.append("(COALESCE(last_seen, '1970-01-01 00:00:00') < ?)")
        args.append(two_hours.isoformat(sep=" "))

    where_sql = ("WHERE " + " AND ".join(where)) if where else ""
    sql = f"""
        SELECT TRIM(COALESCE(dest_city, destination, '')) AS dest,
               COUNT(*) AS c
        FROM flights
        {where_sql}
        GROUP BY TRIM(COALESCE(dest_city, destination, ''))
        ORDER BY c DESC, dest COLLATE NOCASE
        LIMIT 50
    """
    rows = conn.execute(sql, args).fetchall()
    return [(r["dest"], r["c"]) for r in rows if r["dest"]]


# =========================
# UI: ×‘×¨×›×” ××ª×—×œ×¤×ª
# =========================
def _rotating_greeting(now: Optional[dt.datetime] = None) -> str:
    now = now or dt.datetime.utcnow()
    bank = [
        "âœˆï¸ ×‘×¨×•×›×™× ×”×‘××™× ×œ×˜×•×¡×˜×•×¡â€”×××¨×™××™× ×¨×§ ×¢×œ ×“×™×œ×™× ×œ×•×”×˜×™×, ×œ× ×¢×œ ××—×™×¨×™× ğŸ§¯",
        "ğŸ§­ ×˜×•×¡×˜×•×¡ ×›××Ÿ: × ××ª×¨, × ×’×¨×“ ×•× ×‘×™× ×œ×š ×˜×™×¡×•×ª ×©×™×—×××• ××ª ×”×œ×‘ ×•×œ× ××ª ×”××¨× ×§ ğŸ’¸",
        "ğŸ›©ï¸ ×—×•×¡×›×™× ×¢×œ ×”×›×¨×˜×™×¡â€”××‘×–×‘×–×™× ×‘×—×•\"×œ. ×“×™×œ? ××¦×× ×•. ××–×•×•×“×”? ×ª×•×¡×¤×ª ğŸ˜‰",
        "ğŸ˜ ×”×˜×™×™×¡ ×¢×œ ×”×˜×œ×’×¨×: ××ª×” ×¨×§ ×‘×•×—×¨ ×™×¢×“â€”×× ×—× ×• × × ×—×™×ª ×œ×š ××—×™×¨",
    ]
    # ××ª×—×œ×£ ×›×œ ×©×¢×ª×™×™×
    idx = (now.hour // 2) % len(bank)
    return bank[idx]


# =========================
# ×‘× ×™×™×ª ×”××¡×š ×”×¨××©×™ (××•×¤×¦×™×” C â€” ×”×›×•×œ ×¢×œ ×”×”×•×“×¢×”)
# =========================
def _build_main_screen(conn: sqlite3.Connection, s: Dict[str, Any]) -> Tuple[str, InlineKeyboardMarkup]:
    # ×›×•×ª×¨×ª + ×‘×¨×›×”
    greeting = _rotating_greeting()

    # ×¨×©×™××ª ×™×¢×“×™×
    dests = _distinct_destinations(conn)
    # × ×‘×—×¨×™×
    chosen = s["destinations"]
    all_on = ("__ALL__" in chosen) or (chosen and len(chosen) == len(dests))

    def _dest_btn_label(name: str) -> str:
        mark = "âœ…" if (("__ALL__" in chosen) or (name in chosen)) else "â–«ï¸"
        return f"{mark} {name}"

    # × ×™×™×¦×¨ ××§×‘×¦×™× ×©×œ 2 ×‘×¢××•×“×”
    dest_buttons: List[List[InlineKeyboardButton]] = []
    row: List[InlineKeyboardButton] = []
    for d in dests:
        row.append(InlineKeyboardButton(_dest_btn_label(d)[:60], callback_data=f"dest:{d}"))
        if len(row) == 2:
            dest_buttons.append(row)
            row = []
    if row:
        dest_buttons.append(row)

    # ×›×¤×ª×•×¨ â€œ×›×œ ×”×™×¢×“×™×â€
    all_label = "âœ… ×›×œ ×”×™×¢×“×™×" if all_on else "â–«ï¸ ×›×œ ×”×™×¢×“×™×"
    dest_buttons.insert(0, [InlineKeyboardButton(all_label, callback_data="dest:__ALL__")])

    # ×ª××¨×™×›×™× â€” 12 ×™××™× ×§×“×™××”, ×©×•×¨×” ××—×¨ ×©×•×¨×”
    today = dt.date.today()
    date_rows: List[List[InlineKeyboardButton]] = []
    date_selection = s["date"]
    for chunk_start in range(0, 12, 6):
        row = []
        for i in range(chunk_start, min(chunk_start + 6, 12)):
            d = today + dt.timedelta(days=i)
            d_str = d.isoformat()
            checked = "âœ…" if date_selection == d_str else "â–«ï¸"
            label = f"{checked} {d.strftime('%d/%m')}"
            row.append(InlineKeyboardButton(label, callback_data=f"date:{d_str}"))
        date_rows.append(row)
    # ×œ×œ× ×ª××¨×™×š + ×’××™×©×•×ª Â±3
    flex_mark = "âœ…" if s.get("flex3") else "â–«ï¸"
    no_date_mark = "âœ…" if not s.get("date") else "â–«ï¸"
    date_rows.append([
        InlineKeyboardButton(f"{no_date_mark} ×œ×œ× ×ª××¨×™×š", callback_data="date:none"),
        InlineKeyboardButton(f"{flex_mark} Â±3 ×™××™×", callback_data="flex3:toggle"),
    ])

    # ××•×©×‘×™× ××™× ×™××œ×™
    seats = s.get("seats_min", 1)
    seat_row = [
        InlineKeyboardButton(("âœ… " if seats == n else "â–«ï¸ ") + str(n), callback_data=f"seats:{n}")
        for n in [1, 2, 3, 4, 5]
    ]

    # × ×¨××•×ª
    vis = s.get("visibility", "any")
    def vlabel(k, txt): return ("âœ… " if vis == k else "â–«ï¸ ") + txt
    visibility_rows = [[
        InlineKeyboardButton(vlabel("new", "×—×“×©×•×ª (×©×¢×” ××—×¨×•× ×”)"), callback_data="vis:new"),
    ], [
        InlineKeyboardButton(vlabel("live", "×§×™×™××•×ª ×‘××ª×¨"), callback_data="vis:live"),
    ], [
        InlineKeyboardButton(vlabel("old", "×™×©× ×•×ª/×™×¨×“×•"), callback_data="vis:old"),
    ], [
        InlineKeyboardButton(vlabel("any", "×”×›×•×œ"), callback_data="vis:any"),
    ]]

    # ×¡×™×›×•× ×œ×¤×™ ×™×¢×“
    summary = _summary_by_destination(conn, s)
    if summary:
        lines = [f"ğŸ“Š ×¡×™×›×•× ×œ×¤×™ ×™×¢×“ (×¢×“ 50):"]
        for name, c in summary[:10]:
            lines.append(f"â€¢ {name}: {c}")
        summary_text = "\n".join(lines)
    else:
        summary_text = "ğŸ“Š ××™×Ÿ ×ª×•×¦××•×ª ×œ×¡×™× ×•×Ÿ ×”× ×•×›×—×™."

    # ×˜×§×¡×˜
    text = (
        f"{greeting}\n\n"
        f"ğŸ”¹ **×™×¢×“×™×**: ×¡××Ÿ/×™ ×™×¢×“×™× ××ª×•×š ×”×¨×©×™××” (××• '×›×œ ×”×™×¢×“×™×').\n"
        f"ğŸ”¹ **×ª××¨×™×›×™×**: ×‘×—×¨/×™ ×ª××¨×™×š ××“×•×™×§ ××• '×œ×œ× ×ª××¨×™×š'. ××¤×©×¨ ×œ×¡××Ÿ ×’××™×©×•×ª Â±3.\n"
        f"ğŸ”¹ **××•×©×‘×™×**: ××™× ×™××•× ××•×©×‘×™× ×¤× ×•×™×™× ×œ×˜×™×¡×”.\n"
        f"ğŸ”¹ **× ×¨××•×ª**: ×—×“×©×•×ª / ×§×™×™××•×ª / ×™×©× ×•×ª / ×”×›×•×œ.\n\n"
        f"{summary_text}"
    )

    # ×›×¤×ª×•×¨×™ ×¤×¢×•×œ×” ×ª×—×ª×•× ×™×
    action_row = [
        InlineKeyboardButton("ğŸ”„ ×¨×¢× ×•×Ÿ", callback_data="act:refresh"),
        InlineKeyboardButton("ğŸ  ××™×¤×•×¡", callback_data="act:reset"),
    ]

    # ×”×¨×›×‘×ª ×”××§×œ×“×ª
    keyboard: List[List[InlineKeyboardButton]] = []
    keyboard.extend(dest_buttons)
    keyboard.append([InlineKeyboardButton("â€” ×ª××¨×™×›×™× â€”", callback_data="noop")])
    keyboard.extend(date_rows)
    keyboard.append([InlineKeyboardButton("â€” ××™× ×™××•× ××•×©×‘×™× â€”", callback_data="noop")])
    keyboard.append(seat_row)
    keyboard.append([InlineKeyboardButton("â€” × ×¨××•×ª â€”", callback_data="noop")])
    keyboard.extend(visibility_rows)
    keyboard.append(action_row)

    return text, InlineKeyboardMarkup(keyboard)


# =========================
# ×¨× ×“×¨×™× ×’ ×”×•×“×¢×” ×‘×•×“×“×ª ×‘×˜×•×—×” (×œ×”×™×× ×¢ ×-"Message is not modified")
# =========================
async def _safe_edit_message(q, new_text: str, new_km: InlineKeyboardMarkup) -> None:
    old_text = q.message.text or ""
    old_km = q.message.reply_markup
    if old_text == new_text and str(old_km) == str(new_km):
        new_text += "\u2063"  # ×ª×• ×‘×œ×ª×™Ö¾× ×¨××”
    await q.edit_message_text(new_text, reply_markup=new_km)


# =========================
# Handlers
# =========================
async def handle_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.effective_chat.id
    s = _ensure_session(chat_id)

    conn = _conn()
    text, km = _build_main_screen(conn, s)
    await update.effective_message.reply_text(text, reply_markup=km)


async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query
    await q.answer()
    chat_id = update.effective_chat.id
    s = _ensure_session(chat_id)
    data = (q.data or "").strip()

    # ×™×¢×“×™×
    if data.startswith("dest:"):
        val = data.split(":", 1)[1]
        if val == "__ALL__":
            # toggle ALL
            dests = set(_distinct_destinations(_conn()))
            if "__ALL__" in s["destinations"] or s["destinations"] == dests:
                s["destinations"] = set()
            else:
                s["destinations"] = {"__ALL__"}  # ×¡×™××•×Ÿ ×›×œ×œ×™
        else:
            if "__ALL__" in s["destinations"]:
                # ×× ×”×™×” ALLâ€”×”×¡×¨ ××•×ª×• ×•×¢×‘×•×¨ ×œ×‘×—×™×¨×” ×™×“× ×™×ª
                s["destinations"] = set()
            if val in s["destinations"]:
                s["destinations"].remove(val)
            else:
                s["destinations"].add(val)

    # ×ª××¨×™×›×™×
    elif data.startswith("date:"):
        val = data.split(":", 1)[1]
        if val == "none":
            s["date"] = None
        else:
            s["date"] = val  # YYYY-MM-DD
    elif data.startswith("flex3:"):
        s["flex3"] = not s.get("flex3", False)

    # ××•×©×‘×™×
    elif data.startswith("seats:"):
        try:
            s["seats_min"] = int(data.split(":", 1)[1])
        except Exception:
            s["seats_min"] = 1

    # × ×¨××•×ª
    elif data.startswith("vis:"):
        val = data.split(":", 1)[1]
        if val in ("new", "live", "old", "any"):
            s["visibility"] = val

    # ×¤×¢×•×œ×•×ª
    elif data == "act:reset":
        SESS[chat_id] = {
            "destinations": set(),
            "date": None,
            "flex3": False,
            "seats_min": 1,
            "visibility": "any",
        }
        s = SESS[chat_id]
    elif data == "act:refresh":
        pass  # ×œ× ××©× ×” ××ª ×”-state, ×¨×§ ××¨× ×“×¨ ××—×“×©

    # NOOP
    elif data == "noop":
        # ×œ× ×¢×•×©×™× ×›×œ×•×â€”×¨×§ ×¨×¢× ×•×Ÿ ×ª×¦×•×’×”
        pass

    # ×¨×¢× ×•×Ÿ ××¡×š
    conn = _conn()
    text, km = _build_main_screen(conn, s)
    await _safe_edit_message(q, text, km)
