from __future__ import annotations
import re, time, pathlib, logging
from typing import List, Dict, Any, Optional
import requests
from bs4 import BeautifulSoup
import config
import sqlite3
# בראש הקובץ (עם שאר הייבואים)
import asyncio
log = logging.getLogger("tustus.logic")

_SNAP_DIR = pathlib.Path("_snapshots")
_SNAP_DIR.mkdir(exist_ok=True)

def _fetch_html(url: str) -> str:
    """Fetch HTML with UA/timeout מהקונפיג + שמירת סנאפשוט ללוג."""
    ua = getattr(config, "USER_AGENT", "Mozilla/5.0")
    timeout = getattr(config, "REQUEST_TIMEOUT", 15)
    r = requests.get(url, headers={"User-Agent": ua}, timeout=timeout)
    r.raise_for_status()
    html = r.text
    snap = _SNAP_DIR / f"page_{int(time.time())}.html"
    snap.write_text(html, encoding="utf-8")
    log.info("📸 saved HTML snapshot: %s (len=%s)", snap, len(html))
    return html

_price_re = re.compile(r'(?P<cur>[$₪]|USD|שח|ש״ח)\s*([=:]?\s*)?(?P<val>\d+(?:[,.]\d{1,2})?)', re.IGNORECASE)

def _extract_price(txt: str) -> tuple[str, str]:
    """
    שולף מטקסט מטבע וערך כפי שנמצא בעמוד.
    לא מבצע המרה/כפל 3.7 — בדיוק לפי הדרישה.
    """
    m = _price_re.search(txt.replace('\u200f',' ').replace('\u200e',' '))
    if not m:
        return ("", "")
    cur = m.group("cur")
    # normalize Hebrew currency labels למטבע המקור
    if cur in ("שח", "ש״ח"):
        cur = "₪"
    val = m.group("val").replace(',', '.')
    return (cur, val)

def _parse_cards(html: str) -> List[Dict[str, Any]]:
    """
    מנסה כמה סלקטורים טיפוסיים; אם אין התאמות – מחזיר רשימה ריקה אך עם לוג.
    אין הנחת סכמה על ה-DB כאן; רק בניית רשומות לוגיות.
    """
    soup = BeautifulSoup(html, "lxml")

    # דוגמאות סלקטורים – אפשר להרחיב/לשנות אם העמוד השתנה
    candidates = []
    candidates.extend(soup.select(".flight-card, .card.flight, .arkia-card"))
    if not candidates:
        # נסה כרטיסים כלליים עם טקסט יעד/מחיר
        for d in soup.find_all(True):
            txt = (d.get_text(" ", strip=True) or "")
            if ("יעד" in txt or "Destination" in txt) and ("₪" in txt or "$" in txt or "USD" in txt):
                candidates.append(d)

    items: List[Dict[str, Any]] = []
    for i, card in enumerate(candidates, 1):
        text = card.get_text(" ", strip=True)
        cur, val = _extract_price(text)

        # יעד – ננסה לפי כותרת/תווית נפוצה; אם אין, ניקח את הטקסט הגדול בכרטיס
        dest = ""
        dest_el = card.select_one(".dest, .destination, .title, h2, h3")
        if dest_el:
            dest = dest_el.get_text(" ", strip=True)
        if not dest and len(text) < 200:
            dest = text[:120]

        # שדות זמנים (Best-effort; בלי לפרמט ל־datetime—לא נשנה סכמה)
        dep = ""
        arr = ""
        t_el = card.find(string=re.compile(r"\d{1,2}:\d{2}"))
        if t_el:
            # אם מופיע פעמיים, נשאיר בכוונה כטקסט גולמי
            pass

        # מזהה לוגי (נזהר לא לכפות סכמה) — אפשר להשתמש בטקסט מקוצר + מחיר
        rec_id = f"{hash(text) & 0xffffffff:08x}"

        item = {
            "id": rec_id,
            "raw_text": text,
            "destination": dest,
            "price_text": f"{cur}{val}" if cur or val else "",
            "price_currency": cur,
            "price_value": val,
            "removed": 0,
            "updated_at": int(time.time()),
        }
        items.append(item)

    log.info("🧩 parsed %d cards", len(items))
    if not items:
        snap = _SNAP_DIR / f"no_cards_{int(time.time())}.html"
        snap.write_text(html, encoding="utf-8")
        log.warning("⚠️ no cards parsed. saved snapshot: %s", snap)
    return items

def _db_upsert(conn: sqlite3.Connection, items: List[Dict[str, Any]]) -> tuple[int, int]:
    """
    Upsert מינימלי שלא משנה סכמה קיימת:
    - אם יש טבלה show_item עם עמודות מוכרות – נכניס לשם בשיטות גמישות (INSERT OR REPLACE).
    - אחרת נדווח ללוג ולא נפיל.
    """
    cur = conn.cursor()
    # בדיקה עדינה שהטבלה קיימת
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='show_item'")
    if not cur.fetchone():
        log.error("❌ table 'show_item' not found; skipping upsert")
        return (0,0)

    inserted = updated = 0
    for it in items:
        # מיפוי עמודות בסיסי—ננסה להצמיד רק מה שקיים.
        cur.execute("PRAGMA table_info(show_item)")
        cols = {r[1] for r in cur.fetchall()}

        data = {}
        if "id" in cols: data["id"] = it["id"]
        if "destination" in cols: data["destination"] = it["destination"]
        if "price_text" in cols: data["price_text"] = it["price_text"]
        if "price_currency" in cols: data["price_currency"] = it["price_currency"]
        if "price_value" in cols: data["price_value"] = it["price_value"]
        if "raw_text" in cols: data["raw_text"] = it["raw_text"]
        if "removed" in cols: data["removed"] = it["removed"]
        if "updated_at" in cols: data["updated_at"] = it["updated_at"]

        if not data or ("id" not in data):
            # בלי id אין Upsert אמיתי
            continue

        placeholders = ", ".join([f"{k}=excluded.{k}" for k in data.keys() if k != "id"])
        columns = ", ".join(data.keys())
        qmarks = ", ".join(["?"]*len(data))
        sql = f"INSERT INTO show_item ({columns}) VALUES ({qmarks}) ON CONFLICT(id) DO UPDATE SET {placeholders}"
        try:
            cur.execute(sql, tuple(data.values()))
            if cur.rowcount == 1:
                inserted += 1
            else:
                updated += 1
        except Exception as e:
            log.error("upsert failed for id=%s: %s", it.get("id"), e)

    conn.commit()
    log.info("✅ DB upsert (show_item): inserted=%d, updated=%d", inserted, updated)
    return (inserted, updated)

def monitor_job(conn: sqlite3.Connection, app) -> str:
    """
    **ללא שינוי חתימה** – שומר על הדרישה. 
    מביא HTML, מפענח, ומכניס ל-DB. ללא המרות/כפל 3.7.
    """
    html = _fetch_html(config.URL)
    items = _parse_cards(html)
    ins, upd = _db_upsert(conn, items)
    return f"monitor_job done: parsed={len(items)}, inserted={ins}, updated={upd}"

# logic.py

# אם הוספנו קודם import asyncio רק בשביל to_thread ואינו בשימוש יותר — אפשר להשאיר, או להסיר.

async def run_monitor(conn, app):
    """
    מריץ את monitor_job באותו הטראד של ה-JobQueue כדי להימנע מקריסות SQLite.
    לא משנה לוגיקה קיימת, רק מבטל את המעבר לת׳רד נפרד.
    """
    return monitor_job(conn, app)

# ==== PASTE END ====
