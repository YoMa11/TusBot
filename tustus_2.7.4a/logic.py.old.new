from __future__ import annotations
import re, time, pathlib, logging
from typing import List, Dict, Any, Optional
import requests
from bs4 import BeautifulSoup
import config
import sqlite3
# ×‘×¨××© ×”×§×•×‘×¥ (×¢× ×©××¨ ×”×™×™×‘×•××™×)
import asyncio
log = logging.getLogger("tustus.logic")

_SNAP_DIR = pathlib.Path("_snapshots")
_SNAP_DIR.mkdir(exist_ok=True)

def _fetch_html(url: str) -> str:
    """Fetch HTML with UA/timeout ××”×§×•× ×¤×™×’ + ×©××™×¨×ª ×¡× ××¤×©×•×˜ ×œ×œ×•×’."""
    ua = getattr(config, "USER_AGENT", "Mozilla/5.0")
    timeout = getattr(config, "REQUEST_TIMEOUT", 15)
    r = requests.get(url, headers={"User-Agent": ua}, timeout=timeout)
    r.raise_for_status()
    html = r.text
    snap = _SNAP_DIR / f"page_{int(time.time())}.html"
    snap.write_text(html, encoding="utf-8")
    log.info("ğŸ“¸ saved HTML snapshot: %s (len=%s)", snap, len(html))
    return html

_price_re = re.compile(r'(?P<cur>[$â‚ª]|USD|×©×—|×©×´×—)\s*([=:]?\s*)?(?P<val>\d+(?:[,.]\d{1,2})?)', re.IGNORECASE)

def _extract_price(txt: str) -> tuple[str, str]:
    """
    ×©×•×œ×£ ××˜×§×¡×˜ ××˜×‘×¢ ×•×¢×¨×š ×›×¤×™ ×©× ××¦× ×‘×¢××•×“.
    ×œ× ××‘×¦×¢ ×”××¨×”/×›×¤×œ 3.7 â€” ×‘×“×™×•×§ ×œ×¤×™ ×”×“×¨×™×©×”.
    """
    m = _price_re.search(txt.replace('\u200f',' ').replace('\u200e',' '))
    if not m:
        return ("", "")
    cur = m.group("cur")
    # normalize Hebrew currency labels ×œ××˜×‘×¢ ×”××§×•×¨
    if cur in ("×©×—", "×©×´×—"):
        cur = "â‚ª"
    val = m.group("val").replace(',', '.')
    return (cur, val)

def _parse_cards(html: str) -> List[Dict[str, Any]]:
    """
    ×× ×¡×” ×›××” ×¡×œ×§×˜×•×¨×™× ×˜×™×¤×•×¡×™×™×; ×× ××™×Ÿ ×”×ª×××•×ª â€“ ××—×–×™×¨ ×¨×©×™××” ×¨×™×§×” ××š ×¢× ×œ×•×’.
    ××™×Ÿ ×”× ×—×ª ×¡×›××” ×¢×œ ×”-DB ×›××Ÿ; ×¨×§ ×‘× ×™×™×ª ×¨×©×•××•×ª ×œ×•×’×™×•×ª.
    """
    soup = BeautifulSoup(html, "lxml")

    # ×“×•×’×××•×ª ×¡×œ×§×˜×•×¨×™× â€“ ××¤×©×¨ ×œ×”×¨×—×™×‘/×œ×©× ×•×ª ×× ×”×¢××•×“ ×”×©×ª× ×”
    candidates = []
    candidates.extend(soup.select(".flight-card, .card.flight, .arkia-card"))
    if not candidates:
        # × ×¡×” ×›×¨×˜×™×¡×™× ×›×œ×œ×™×™× ×¢× ×˜×§×¡×˜ ×™×¢×“/××—×™×¨
        for d in soup.find_all(True):
            txt = (d.get_text(" ", strip=True) or "")
            if ("×™×¢×“" in txt or "Destination" in txt) and ("â‚ª" in txt or "$" in txt or "USD" in txt):
                candidates.append(d)

    items: List[Dict[str, Any]] = []
    for i, card in enumerate(candidates, 1):
        text = card.get_text(" ", strip=True)
        cur, val = _extract_price(text)

        # ×™×¢×“ â€“ × × ×¡×” ×œ×¤×™ ×›×•×ª×¨×ª/×ª×•×•×™×ª × ×¤×•×¦×”; ×× ××™×Ÿ, × ×™×§×— ××ª ×”×˜×§×¡×˜ ×”×’×“×•×œ ×‘×›×¨×˜×™×¡
        dest = ""
        dest_el = card.select_one(".dest, .destination, .title, h2, h3")
        if dest_el:
            dest = dest_el.get_text(" ", strip=True)
        if not dest and len(text) < 200:
            dest = text[:120]

        # ×©×“×•×ª ×–×× ×™× (Best-effort; ×‘×œ×™ ×œ×¤×¨××˜ ×œÖ¾datetimeâ€”×œ× × ×©× ×” ×¡×›××”)
        dep = ""
        arr = ""
        t_el = card.find(string=re.compile(r"\d{1,2}:\d{2}"))
        if t_el:
            # ×× ××•×¤×™×¢ ×¤×¢××™×™×, × ×©××™×¨ ×‘×›×•×•× ×” ×›×˜×§×¡×˜ ×’×•×œ××™
            pass

        # ××–×”×” ×œ×•×’×™ (× ×–×”×¨ ×œ× ×œ×›×¤×•×ª ×¡×›××”) â€” ××¤×©×¨ ×œ×”×©×ª××© ×‘×˜×§×¡×˜ ××§×•×¦×¨ + ××—×™×¨
        rec_id = f"{hash(text) & 0xffffffff:08x}"

        item = {
            "id": rec_id,
            "raw_text": text,
            "destination": dest,
            "price_text": f"{cur}{val}" if cur or val else "",
            "price_currency": cur,
            "price_value": val,
            "removed": 0,
            "updated_at": int(time.time()),
        }
        items.append(item)

    log.info("ğŸ§© parsed %d cards", len(items))
    if not items:
        snap = _SNAP_DIR / f"no_cards_{int(time.time())}.html"
        snap.write_text(html, encoding="utf-8")
        log.warning("âš ï¸ no cards parsed. saved snapshot: %s", snap)
    return items

def _db_upsert(conn: sqlite3.Connection, items: List[Dict[str, Any]]) -> tuple[int, int]:
    """
    Upsert ××™× ×™××œ×™ ×©×œ× ××©× ×” ×¡×›××” ×§×™×™××ª:
    - ×× ×™×© ×˜×‘×œ×” show_item ×¢× ×¢××•×“×•×ª ××•×›×¨×•×ª â€“ × ×›× ×™×¡ ×œ×©× ×‘×©×™×˜×•×ª ×’××™×©×•×ª (INSERT OR REPLACE).
    - ××—×¨×ª × ×“×•×•×— ×œ×œ×•×’ ×•×œ× × ×¤×™×œ.
    """
    cur = conn.cursor()
    # ×‘×“×™×§×” ×¢×“×™× ×” ×©×”×˜×‘×œ×” ×§×™×™××ª
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='show_item'")
    if not cur.fetchone():
        log.error("âŒ table 'show_item' not found; skipping upsert")
        return (0,0)

    inserted = updated = 0
    for it in items:
        # ××™×¤×•×™ ×¢××•×“×•×ª ×‘×¡×™×¡×™â€”× × ×¡×” ×œ×”×¦××™×“ ×¨×§ ××” ×©×§×™×™×.
        cur.execute("PRAGMA table_info(show_item)")
        cols = {r[1] for r in cur.fetchall()}

        data = {}
        if "id" in cols: data["id"] = it["id"]
        if "destination" in cols: data["destination"] = it["destination"]
        if "price_text" in cols: data["price_text"] = it["price_text"]
        if "price_currency" in cols: data["price_currency"] = it["price_currency"]
        if "price_value" in cols: data["price_value"] = it["price_value"]
        if "raw_text" in cols: data["raw_text"] = it["raw_text"]
        if "removed" in cols: data["removed"] = it["removed"]
        if "updated_at" in cols: data["updated_at"] = it["updated_at"]

        if not data or ("id" not in data):
            # ×‘×œ×™ id ××™×Ÿ Upsert ×××™×ª×™
            continue

        placeholders = ", ".join([f"{k}=excluded.{k}" for k in data.keys() if k != "id"])
        columns = ", ".join(data.keys())
        qmarks = ", ".join(["?"]*len(data))
        sql = f"INSERT INTO show_item ({columns}) VALUES ({qmarks}) ON CONFLICT(id) DO UPDATE SET {placeholders}"
        try:
            cur.execute(sql, tuple(data.values()))
            if cur.rowcount == 1:
                inserted += 1
            else:
                updated += 1
        except Exception as e:
            log.error("upsert failed for id=%s: %s", it.get("id"), e)

    conn.commit()
    log.info("âœ… DB upsert (show_item): inserted=%d, updated=%d", inserted, updated)
    return (inserted, updated)

def monitor_job(conn: sqlite3.Connection, app) -> str:
    """
    **×œ×œ× ×©×™× ×•×™ ×—×ª×™××”** â€“ ×©×•××¨ ×¢×œ ×”×“×¨×™×©×”. 
    ××‘×™× HTML, ××¤×¢× ×—, ×•××›× ×™×¡ ×œ-DB. ×œ×œ× ×”××¨×•×ª/×›×¤×œ 3.7.
    """
    html = _fetch_html(config.URL)
    items = _parse_cards(html)
    ins, upd = _db_upsert(conn, items)
    return f"monitor_job done: parsed={len(items)}, inserted={ins}, updated={upd}"

# logic.py

# ×× ×”×•×¡×¤× ×• ×§×•×“× import asyncio ×¨×§ ×‘×©×‘×™×œ to_thread ×•××™× ×• ×‘×©×™××•×© ×™×•×ª×¨ â€” ××¤×©×¨ ×œ×”×©××™×¨, ××• ×œ×”×¡×™×¨.

async def run_monitor(conn, app):
    """
    ××¨×™×¥ ××ª monitor_job ×‘××•×ª×• ×”×˜×¨××“ ×©×œ ×”-JobQueue ×›×“×™ ×œ×”×™×× ×¢ ××§×¨×™×¡×•×ª SQLite.
    ×œ× ××©× ×” ×œ×•×’×™×§×” ×§×™×™××ª, ×¨×§ ××‘×˜×œ ××ª ×”××¢×‘×¨ ×œ×ª×³×¨×“ × ×¤×¨×“.
    """
    return monitor_job(conn, app)

# ==== PASTE END ====
